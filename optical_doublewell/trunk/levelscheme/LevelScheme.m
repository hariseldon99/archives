(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* :Title: LevelScheme *)
(* :Context: LevelScheme` *)
(* :Summary: Scientific figure preparation system *)
(* :Author: Mark A. Caprio, Department of Physics, University of Notre Dame *)
(* :Copyright: Copyright 2007, Mark A. Caprio *)
(* :Package Version: 3.40 *)
(* :Mathematica Version: 6.0 *)
(* :History:
Early ancestor code, July 1999.
   V1.00, January 2004 (first web release). 
V2.00, November 2004.  
 V3.00, March 2005.
 V3.01, March 2005.
 V3.02, April 2005.
 V3.10, April 2005 (CPCPL distribution).
V3.11, May 2005.
   V3.20, October 2005.
   V3.21, October 2005.
 V3.30, July 2007.
V3.40, August 2007.
V3.41, September 2007.
*)
(* :Discussion:
 The LevelScheme package has been published in Computer Physics Communications, M. A. Caprio, Comput. Phys. Commun. 171, 107 (2005).  Updates and further information may be obtained through the LevelScheme home page, www.levelscheme.org.  If you modify the software, you *must* change the package name and *must* change the message displayed when the package is loaded, to clearly indicate that the package is a modified version.
*)


LevelScheme`Private`$RevisionString="3.41 (September 11, 2007)";
LevelScheme`Private`$HomePageURL="http://wnsl.physics.yale.edu/levelscheme/notebook_entrance_3.41.html";


If[$VersionNumber<6.0,Print["This version of LevelScheme requires Mathematica 6 or higher.  You are currently running Mathematica "<>ToString[IntegerPart[$VersionNumber]]<>".  Please visit the LevelScheme home page (http://wnsl.physics.yale.edu/levelscheme) to download the appropriate earlier version of LevelScheme for use with your Mathematica."];
Abort[]
];


BeginPackage["LevelScheme`",{"CustomTicks`","MCText`","ForEach`" ,"BlockOptions`","InheritOptions`","ClipToRectangle`","Graphics`Common`GraphicsCommon`","LegacyColors`","NamedColorPalette`"}];


Unprotect[Evaluate[$Context<>"*"]];


SchemeObject::usage="Parent object for option inheritance for level scheme objects.";


Color::usage="Option for level scheme drawing objects.";
Opacity::reusage="Option for level scheme drawing objects."; (*System`*)
ShowLine::usage="Option for level scheme drawing objects."; 
LineColor::usage="Option for level scheme drawing objects."; 
LineOpacity::usage="Option for level scheme drawing objects."; 
Thickness::reusage="Option for level scheme drawing objects.";  (*System`*)
Dashing::reusage="Option for level scheme drawing objects.";  (*System`*)
DashingGap::usage="Option for level scheme drawing objects."; 
DashingCorrection::usage="Option for level scheme drawing objects."; 
ShowFill::usage="Option for level scheme drawing objects."; 
FillColor::usage="Option for level scheme drawing objects."; 
FillOpacity::usage="Option for level scheme drawing objects."; 
(*FontXXXXXX options are all from System`. *)
BackgroundFontSizeFactor::usage="Option for level scheme drawing objects."; 
Show::reusage="Option for level scheme drawing objects."; (*System`*)
Layer::usage="Option for level scheme drawing objects."; 


ShowText::usage="Option for level scheme drawing objects."; 
Offset::reusage="Option for level scheme drawing objects.";   (*System`*)
Nudge::usage="Option for level scheme drawing objects."; 
Orientation::usage="Option for level scheme drawing objects."; 
Background::reusage="Option for level scheme drawing objects.";   (*System`*)
BackgroundOpacity::usage="Option for level scheme drawing objects.";

LabL::usage="Option for level scheme drawing objects."; 
ShowLabL::usage="Option for level scheme drawing objects."; 
OffsetL::usage="Option for level scheme drawing objects."; 
NudgeL::usage="Option for level scheme drawing objects."; 
OrientationL::usage="Option for level scheme drawing objects."; 
BackgroundL::usage="Option for level scheme drawing objects."; 
BackgroundOpacityL::usage="Option for level scheme drawing objects."; 
PosnL::usage="Option for level scheme drawing objects."; 
BufferL::usage="Option for level scheme drawing objects."; 
AboveKinkL::usage="Option for level scheme drawing objects.";
SegmentL::usage="Option for level scheme drawing objects.";

LabR::usage="Option for level scheme drawing objects."; 
ShowLabR::usage="Option for level scheme drawing objects."; 
OffsetR::usage="Option for level scheme drawing objects."; 
NudgeR::usage="Option for level scheme drawing objects."; 
OrientationR::usage="Option for level scheme drawing objects."; 
BackgroundR::usage="Option for level scheme drawing objects."; 
BackgroundOpacityR::usage="Option for level scheme drawing objects."; 
PosnR::usage="Option for level scheme drawing objects."; 
BufferR::usage="Option for level scheme drawing objects."; 
AboveKinkR::usage="Option for level scheme drawing objects."; 
SegmentR::usage="Option for level scheme drawing objects.";

LabT::usage="Option for level scheme drawing objects."; 
ShowLabT::usage="Option for level scheme drawing objects."; 
OffsetT::usage="Option for level scheme drawing objects."; 
NudgeT::usage="Option for level scheme drawing objects."; 
OrientationT::usage="Option for level scheme drawing objects."; 
BackgroundT::usage="Option for level scheme drawing objects."; 
BackgroundOpacityT::usage="Option for level scheme drawing objects."; 
PosnT::usage="Option for level scheme drawing objects."; 
BufferT::usage="Option for level scheme drawing objects."; 
AboveKinkT::usage="Option for level scheme drawing objects."; 
SegmentT::usage="Option for level scheme drawing objects.";

LabB::usage="Option for level scheme drawing objects."; 
ShowLabB::usage="Option for level scheme drawing objects."; 
OffsetB::usage="Option for level scheme drawing objects."; 
NudgeB::usage="Option for level scheme drawing objects."; 
OrientationB::usage="Option for level scheme drawing objects."; 
BackgroundB::usage="Option for level scheme drawing objects."; 
BackgroundOpacityB::usage="Option for level scheme drawing objects."; 
PosnB::usage="Option for level scheme drawing objects."; 
BufferB::usage="Option for level scheme drawing objects."; 
AboveKinkB::usage="Option for level scheme drawing objects."; 
SegmentB::usage="Option for level scheme drawing objects.";

LabC::usage="Option for level scheme drawing objects."; 
ShowLabC::usage="Option for level scheme drawing objects."; 
OffsetC::usage="Option for level scheme drawing objects."; 
NudgeC::usage="Option for level scheme drawing objects."; 
OrientationC::usage="Option for level scheme drawing objects."; 
BackgroundC::usage="Option for level scheme drawing objects."; 
BackgroundOpacityC::usage="Option for level scheme drawing objects."; 
PosnC::usage="Option for level scheme drawing objects."; 
BufferC::usage="Option for level scheme drawing objects."; 
AboveKinkC::usage="Option for level scheme drawing objects."; 
SegmentC::usage="Option for level scheme drawing objects.";

LabX::usage="Option for level scheme drawing objects."; 
ShowLabX::usage="Option for level scheme drawing objects."; 
OffsetX::usage="Option for level scheme drawing objects."; 
NudgeX::usage="Option for level scheme drawing objects."; 
OrientationX::usage="Option for level scheme drawing objects."; 
BackgroundX::usage="Option for level scheme drawing objects."; 
BackgroundOpacityX::usage="Option for level scheme drawing objects."; 
PosnX::usage="Option for level scheme drawing objects."; 
BufferX::usage="Option for level scheme drawing objects."; 
AboveKinkX::usage="Option for level scheme drawing objects."; 
SegmentX::usage="Option for level scheme drawing objects.";


Ticks::reusage="Option for level scheme drawing objects."; (*System`*)
TickShowLine::usage="Option for level scheme drawing objects."; 
TickLineColor::usage="Option for level scheme drawing objects."; 
TickThickness::usage="Option for level scheme drawing objects."; 
TickFontColor::usage="Option for level scheme drawing objects."; 
TickFontOpacity::usage="Option for level scheme drawing objects."; 
TickFontFamily::usage="Option for level scheme drawing objects."; 
TickFontSize::usage="Option for level scheme drawing objects."; 
TickFontSlant::usage="Option for level scheme drawing objects."; 
TickFontTracking::usage="Option for level scheme drawing objects."; 
TickFontWeight::usage="Option for level scheme drawing objects."; 
TickNudge::usage="Option for level scheme drawing objects."; 


PanelLetterFontColor::usage="Option for level scheme drawing objects."; 
PanelLetterFontOpacity::usage="Option for level scheme drawing objects."; 
PanelLetterFontFamily::usage="Option for level scheme drawing objects."; 
PanelLetterFontSize::usage="Option for level scheme drawing objects."; 
PanelLetterFontSlant::usage="Option for level scheme drawing objects."; 
PanelLetterFontTracking::usage="Option for level scheme drawing objects."; 
PanelLetterFontWeight::usage="Option for level scheme drawing objects."; 
ShowPanelLetter::usage="Option for level scheme drawing objects."; 
PanelLetterOffset::usage="Option for level scheme drawing objects.";
PanelLetterNudge::usage="Option for level scheme drawing objects."; 
PanelLetterOrientation::usage="Option for level scheme drawing objects."; 
PanelLetterBackground::usage="Option for level scheme drawing objects.";  
PanelLetterBackgroundOpacity::usage="Option for level scheme drawing objects."; 


Margin::usage="Option for level scheme drawing objects."; 
EnergyLabelFunction::usage="Option for level scheme drawing objects.";  
EnergyNudge::usage="Option for level scheme drawing objects."; 
WingHeight::usage="Option for level scheme drawing objects."; 
WingRiseWidth::usage="Option for level scheme drawing objects."; 
WingTipWidth::usage="Option for level scheme drawing objects."; 
MakeWingL::usage="Option for level scheme drawing objects."; 
MakeWingR::usage="Option for level scheme drawing objects."; 
ToWing::usage="Option for level scheme drawing objects."; 
FromWing::usage="Option for level scheme drawing objects."; 
LineToFront::usage="Option for level scheme drawing objects. (UNDOCUMENTED)"; 
EndPositions::usage="Option for level scheme drawing objects."; 
ArrowType::usage="Option for level scheme drawing objects."; 
ArrowHalf::usage="Option for level scheme drawing objects. (UNDOCUMENTED)"; 
Width::usage="Option for level scheme drawing objects."; 
SquiggleWavelength::usage="Option for level scheme drawing objects."; 
SquiggleSide::usage="Option for level scheme drawing objects."; 
SquiggleBuffer::usage="Option for level scheme drawing objects."; 
PlotPoints::reusage="Option for level scheme drawing objects.";(*System`*)
TailBevel::usage="Option for level scheme drawing objects."; 
ShaftLines::usage="Option for level scheme drawing objects."; 
HeadLength::reusage="Option for level scheme drawing objects.";(*Graphics`Arrow`*)
HeadLip::usage="Option for level scheme drawing objects."; 
Kink::usage="Option for level scheme drawing objects."; 
ShowHead::usage="Option for level scheme drawing objects."; 
ShowTail::usage="Option for level scheme drawing objects."; 
ConversionColor::usage="Option for level scheme drawing objects."; 
ConversionSide::usage="Option for level scheme drawing objects."; 
ConversionCoeff::usage="Option for level scheme drawing objects."; 
CallOutVector::usage="Option for level scheme drawing objects."; 
Gap::usage="Option for level scheme drawing objects."; 


Frame::reusage="Option for Scheme.";(*System`*)
FrameLabel::reusage="Option for Scheme.";(*System`*)
FrameTicks::reusage="Option for Scheme.";(*System`*)
Axes::reusage="Option for Scheme.";(*System`*)
PlotRange::reusage="Option for Scheme.";(*System`*)
ImageSize::reusage="Option for Scheme.";(*System`*)
DisplayFunction::reusage="Option for Scheme.";(*System`*)
SchemeFlags::usage="Option for Scheme.";
BlockOptions::reusage="Option for Scheme.";(*BlockOptions`*)
Information::reusage="Option for Scheme. (UNDOCUMENTED)";(*System`*)
Debug::reusage="Option for Scheme. (UNDOCUMENTED)";(*System`*)


Inverted::usage="Option value for level scheme drawing objects.";
LineArrow::usage="Option value for level scheme drawing objects.";
MultilineArrow::usage="Option value for level scheme drawing objects.";
SquiggleArrow::usage="Option value for level scheme drawing objects.";
ShapeArrow::usage="Option value for level scheme drawing objects.";
FromHead::usage="Option value for level scheme drawing objects.";
FromTail::usage="Option value for level scheme drawing objects.";
FromHeadVertical::usage="Option value for level scheme drawing objects.";
FromTailVertical::usage="Option value for level scheme drawing objects.";
FromHeadHorizontal::usage="Option value for level scheme drawing objects.";
FromTailHorizontal::usage="Option value for level scheme drawing objects.";


SetOrigin::usage="SetOrigin[x] or SetOrigin[pt] sets the origin of the user coordinate system.  SetOrigin[] clears the definition.";
SetScale::usage="SetScale[yfactor] or SetScale[{xfactor,yfactor}] sets the scaling of the user coordinate system.  SetScale[] clears the definition.";
SetRegion::usage="SetRegion[{{xc1,xc2},{yc1,yc2}},{{xr1,xr2},{yr1,yr2}}] sets the region coordinate system and clipping box.  Any existing user coordinate definitions (origin or scale) are cleared.  SetRegion[] resets the region to the full canvas.";


ConvertCoordinate::usage="ConvertCoordinate[system,newsystem,type,{x,y}] or ConvertCoordinate[system,newsystem,type,x,index] carries out coordinate system conversion.  The systems can be specified to be CanvasCoords, RegionCoords, UserCoords, AbsoluteCoords, or ScaledCoords.  The type (C or D) indicates coordinate or displacement conversion.  The index (1 or 2) indicates X or Y coordinate conversion.";
ConvertRange::usage="ConvertRange[system,newsystem,type,{x1,x2},index] carries out coordinate system conversion for X or Y ranges.  The arguments have similar meanings as for ConvertCoordinate.";
ConvertRegion::usage="ConvertRegion[system,newsystem,type,{{x1,x2},{y1,y2}}] carries out coordinate system conversion for regions.  The arguments have similar meanings as for ConvertCoordinate.";


C::reusage="Conversion type identifier for ConvertCoordinate."; (*System`*)
D::reusage="Conversion type identifier for ConvertCoordinate."; (*System`*)
CanvasCoords::usage="Level scheme drawing coordinate system identifier.";
AbsoluteCoords::usage="Level scheme drawing coordinate system identifier.";
RegionCoords::usage="Level scheme drawing coordinate system identifier.";
ScaledCoords::usage="Level scheme drawing coordinate system identifier.";
UserCoords::usage="Level scheme drawing coordinate system identifier.";


SavePoint::usage="SavePoint[ID,{x,y}] or SavePoint[ID,{x,y},system] saves the canvas position of the given point.  If no coordinate system is specified, it is assumed {x,y} are the coordinates in the current user coordinate system.";
GetPoint::usage="GetPoint[ID] or GetPoint[ID,system] returns the position of the previously saved point, converted to the presently-defined coordinate systems.  If no coordinate system is specified, the point is given in the current user coordinates.";


Figure::usage="Figure[list] returns a drawing constructed from the objects in list.";
ExtendRange::reusage="Option for Figure."; (* LevelScheme` *)
SchemeIfDef::usage="SchemeIfDef[Flag,Object1,...] evaluates objects and splices them into the figure only if Flag is defined in the SchemeFlags option.";
SchemeIfNDef::usage="SchemeIfNDef[Flag,Object1,...] evaluates objects and splices them into the figure only if Flag is *not* defined in the SchemeFlags option.";


Lev::usage="Lev[ID,x1,x2,Energy] is a level scheme drawing object.";
ExtensionLine::usage="ExtensionLine[ID,position1,position2] or ExtensionLine[ID,side,length] is a level scheme drawing object.";
LastLevel::usage="LastLevel is a global variable containing the ID of the most recently defined level.";
LevelEnergy::usage="LevelEnergy[ID] returns the energy value (user coordinate) specified when the given level was defined.";
Connector::usage="Connector[ID1,ID2] is a level scheme drawing object.";


Trans::usage="Trans[ID1,position1,ID2,position2] or Trans[ID1,ID2] or Trans[pt1,pt2] is a level scheme drawing object.";


SchemeLine::usage="SchemeLine[{pt1,pt2,...}] is a level scheme drawing object.";
SchemePolygon::usage="SchemePolygon[{pt1,pt2,...}] is a level scheme drawing object.";
SchemeCircle::usage="SchemeCircle[pt,radius] or SchemeCircle[pt,radius,{theta1,theta2}] is a level scheme drawing object.";
SchemeEllipse::usage="SchemeEllipse[pt,{r1,r2},theta] is a level scheme drawing object.";
SchemeBox::usage="SchemeBox[{{x1,x2},{y1,y2}}] or SchemeBox[pt1,pt2] is a level scheme drawing object.";
SchemeSquare::usage="SchemeSquare[pt,radius] is a level scheme drawing object.";
SchemeArrow::usage="SchemeArrow[pt1,pt2] is a level scheme drawing object.";
SchemeBracket::usage="SchemeBracket[Bottom|Top,{x1,x2},y] or SchemeBracket[Left|Right,x,{y1,y2}] is a level scheme drawing object.  Level IDs may be specified instead of coordinates, as SchemeBracket[Bottom|Top,{ID1,ID2},y] or SchemeBracket[Left|Right,x,{ID1,ID2}].";
SchemeLine3D::usage="SchemeLine3D[{pt1,pt2,...}] is a 3D analogue of a level scheme drawing object.";
SchemeArrow3D::usage="SchemeArrow3D[pt1,pt2] or SchemeArrow3D[pt1,pt2,headangle] is a 3D analogue of a level scheme drawing object.";


ManualLabel::usage="ManualLabel[pt,text] is a level scheme drawing object.";
ScaledLabel::usage="ScaledLabel[scaledpt,text] is a level scheme drawing object.";
BandLabel::usage="BandLabel[ID,text] or BandLabel[ID,position,text] is a level scheme drawing object.";
LevelLabel::usage="LevelLabel[ID,position,text] is a level scheme drawing object.";
ManualLabel3D::usage="ManualLabel3D[pt,text] is a 3D analogue of a level scheme drawing object.";


RawGraphics::usage="RawGraphics[graphics1,...] is a level scheme drawing object which includes Graphics, ContourGraphics, or DensityGraphics objects in the scheme.";
RawGraphics3D::usage="RawGraphics3D[graphics1,...] is a level scheme drawing object.";
ClipToRectangle::reusage="Option for level scheme drawing objects."; (*ClipToRectangle`*)


ViewPort3D::usage="ViewPort3D[{graphics,...},{{x1,x2},{y1,y2}}] is a level scheme drawing object which includes three-dimensional graphics objects in the scheme.";
ScaledViewPort3D::usage="ScaledViewPort3D[{graphics,...},{{x1s,x2s},{y1s,y2s}}] is a level scheme drawing object which includes three-dimensional graphics objects in the scheme.";
AxisScaling::usage="Option for ViewPort3D.";
EulerRotation::usage="Option for ViewPort3D.";


SchemeAxis::usage="SchemeAxis[Bottom|Top,{x1,x2},y] or SchemeAxis[Left|Right,x,{y1,y2}] generates a freestanding axis.";
FigurePanel::usage="FigurePanel[{{xc1,xc2},{yc1,yc2}}] sets the region coordinate system and draws a panel frame, labels, and fill.  The panel position is specified in canvas coordinates.  FigurePanel[{row,column}] generates a panel of a multipanel plot.";
ScaledFigurePanel::usage="ScaledFigurePanel[{{xs1,xs2},{ys1,ys2}}] sets the region coordinate system and draws a panel frame, labels, and fill.  The panel position is specified in scaled coordinates relative to the present plotting region.";
PlotRange::reusage="Option for FigurePanel.";(*System`*)
XPlotRange::usage="Option for FigurePanel.";
YPlotRange::usage="Option for FigurePanel.";
ShowEdge::usage="Option for FigurePanel.";
Multipanel::usage="Multipanel[{{xc3,xc4},{yc3,yc4}},{rows,columns}] initializes automatic multipanel plotting.";
XPlotRanges::usage="Option for Multipanel.";
YPlotRanges::usage="Option for Multipanel.";
XFrameTicks::usage="Option for automatic panel generation.";
YFrameTicks::usage="Option for automatic panel generation.";
XFrameLabels::usage="Option for automatic panel generation.";
YFrameLabels::usage="Option for automatic panel generation.";
XPanelSizes::usage="Option for automatic panel generation.";
YPanelSizes::usage="Option for automatic panel generation.";
XGapSizes::usage="Option for automatic panel generation.";
YGapSizes::usage="Option for automatic panel generation.";
XMarginSizes::usage="Option for automatic panel generation.";
YMarginSizes::usage="Option for automatic panel generation.";
PanelShift::usage="Option for Panel, only relevant when used with automatic panel generation.";
PanelAdjustments::usage="Option for Panel, only relevant when used with automatic panel generation.";
ShowTicks::usage="Option for automatic panel generation.";
ShowTickLabels::reusage="Option for automatic panel generation.";(*CustomTicks`*)
ShowTickLabelsExterior::usage="Option for automatic panel generation.";
ShowTickLabelsInterior::usage="Option for automatic panel generation.";
ShowFrameLabels::reusage="Option for automatic panel generation.";
ShowFrameLabelsExterior::usage="Option for automatic panel generation.";
ShowFrameLabelsInterior::usage="Option for automatic panel generation.";
PanelLetterCorner::usage="Option for level scheme drawing objects.";
PanelLetterInset::usage="Option for Panel.";
PanelLetter::usage="PanelLetter[] returns the letter for the current panel of a multipanel plot.";
Order::reusage="Option for PanelLetter.";(*System`*)
First::reusage="Option for PanelLetter.";(*System`*)
Format::reusage="Option for PanelLetter.";(*System`*)


AttachIndex::usage="(UNDOCUMENTED)";
ScaleFactor::reusage="Option for AttachIndex."; (*Graphics`Common`GraphicsCommon`ScaleFactor`*)
Range::reusage="Option for AttachIndex."; (*System`*)
DataSetQ::usage="DataSetQ[list] returns True only if list is a valid LevelScheme data set.";


SelectData::usage="SelectData[test] is a data filter for DataPlot.";
ExcludeData::usage="ExcludeData[test] is a data filter for DataPlot.";
TransformData::usage="TransformData[f] is a data filter for DataPlot.";
DownsampleData::usage="DownsampleData[f] is a data filter for DataPlot.";
XRange::usage="XRange[x1,x2] is a logical text which acts on a data point.";
YRange::usage="YRange[y1,y2] is a logical text which acts on a data point.";
InPlotRegion::usage="InPlotRegion is a data filter for DataPlot.";
LimitX::usage="LimitX[x1,x2] is a data filter for DataPlot.";
LimitY::usage="LimitY[y1,y2] is a data filter for DataPlot.";


DataPlot::usage="DataPlot[data] produces customizable data plots.";
DataTag::usage="DataTag[ID] sets the name of the following data set.";
SaveDataStyle::usage="SaveDataStyle[ID] saves the current plotting options.";
SetDataStyle::usage="SetDataStyle[ID] sets the plotting options to those of the given named data set.";
DataLabel::usage="DataLabel[ID] attaches text to a data plot.";
DataLegend::usage="DataPlot[{xs,ys},{{dataset1,label1},...}] generates a data plot legend.";
DataTransformation::usage="Symbol the option values for which control the behavior of DataPlot.";
DataLine::usage="Symbol the option values for which control the behavior of DataPlot.";
DataSymbol::usage="Symbol the option values for which control the behavior of DataPlot.";
ShowData::usage="Option for level scheme drawing objects."; 
LineShape::reusage="Option for level scheme drawing objects."; 
DataFilters::usage="Option for level scheme drawing objects."; 
SymbolShape::reusage="Option for level scheme drawing objects."; (*Graphics`MultipleListPlot`*)
ErrorValue::usage="Value type for data points.";
SymbolSize::usage="Option for level scheme drawing objects."; 
DataLineShape::usage="Symbol used for specification of LevelScheme plot line shape.  DataLineShape[shape,plotpoints] should act on a list of points, transforming it to another list of points.";DataSymbolShape::usage="Symbol used for specification of LevelScheme plot symbol shape.  DataSymbolShape[shape,plotpoints] should return a list of points, spanning approximately the unit circle.";


AutoLevelInit::usage="AutoLevelInit[x0,space,bigspace] initializes automatic placement of transitions in a decay scheme.";
AutoLevel::usage="AutoLevel[ID1] selects the starting level for automatic placement of transitions in a decay scheme.";
AutoTrans::usage="AutoTrans[ID2] generates a transition to the specified ending level for automatic placement of transitions in a decay scheme.";


GrabPoints::usage="GrabPoints[graphics] returns the list of points from the first Line found by ExtractLines[graphics].";
ExtractLines::usage="ExtractLines[graphics] extracts a list of Line objects from a Graphics, ContourGraphics, or Graphics3D object.";
Graphics3DQ::usage="Graphics3DQ[x] returns True if x is a Graphics3D object, with first argument of head list and optional second argument a flat list of options.";
CombineGraphics3D::usage="CombineGraphics3D[{graphics1,...}] returns a Graphics3D object with a primative list combining the primative lists of graphics1, ..., each as separate sublists (so style directives in one sublist do not affect the following sublists).";
ExtendRange::usage="ExtendRange[{x1,x2},{fx1,fx2}] or ExtendRange[{x1,x2},fx] extends an interval by the specified fractional amounts in each direction.";
ExtendRegion::usage="ExtendRegion[{{x1,x2},{y1,y2}},{{fx1,fx2},{fy1,fy2}}] or ExtendRegion[{{x1,x2},{y1,y2}},{fx,fy}] or ExtendRegion[{{x1,x2},{y1,y2}},f] extends a plot region by the specified fractional amounts in each direction.";


SchemeGraphics::usage="Graphics container for LevelScheme objects.";LineStyle::usage="LineStyle[] returns a list of line style directives specified following the LevelScheme option system.";
FillStyle::usage="FillStyle[] returns a list of fill style directives specified following the LevelScheme option system.";
LevelScheme::usage="Evaluating LevelScheme[] reloads the LevelScheme package. (UNDOCUMENTED)";
MultipanelSettings::usage="MultipanelSettings[] prints the current Multipanel plotting settings. (UNDOCUMENTED)";
PackageVersions::usage="Evaluating PackageVersions[] displays package version information for all loaded packages. (UNDOCUMENTED)";


ExtensionLineL::deprecated="ExtensionLineL (last used in LevelScheme 2.0) has been absorbed into ExtensionLine.";
ExtensionLineR::deprecated="ExtensionLineR (last used in LevelScheme 2.0) has been absorbed into ExtensionLine.";
TransArrow::deprecated="TransArrow (last used in LevelScheme 2.0) has been absorbed into Trans.";
RegionLabel::deprecated="RegionLabel (last used in LevelScheme 2.0) has been replaced with ScaledLabel.";
AnnotateL::deprecated="AnnotateL (last used in LevelScheme 2.0) has been replaced with LevelLabel.";
AnnotateR::deprecated="AnnotateR (last used in LevelScheme 2.0) has been replaced with LevelLabel.";
SchemeAxisB::deprecated="SchemeAxisB (last used in LevelScheme 2.0) has been replaced with SchemeAxis.";
SchemeAxisL::deprecated="SchemeAxisL (last used in LevelScheme 2.0) has been replaced with SchemeAxis.";
SchemeAxisT::deprecated="SchemeAxisT (last used in LevelScheme 2.0) has been replaced with SchemeAxis.";
SchemeAxisR::deprecated="SchemeAxisR (last used in LevelScheme 2.0) has been replaced with SchemeAxis.";
AutoInit::deprecated="AutoInit (last used in LevelScheme 2.0) has been renamed AutoLevelInit.";
AutoPanelInit::replaced="AutoPanelInit (last used in LevelScheme 2.0) has been replaced with Multipanel.";
AutoPanel::replaced="AutoPanel (last used in LevelScheme 2.0) has been replaced with Panel.  Use SetRegion[] to turn off multipanel plotting.";
SetSchemeOrigin::deprecated="SetSchemeOrigin (last used in LevelScheme 2.0) has been replaced with SetOrigin.";
SetSchemeScale::deprecated="SetSchemeScale (last used in LevelScheme 2.0) has been replaced with SetScale.";
SetSchemeRegion::deprecated="SetSchemeRegion (last used in LevelScheme 2.0) has been replaced with SetRegion.";
ResetCoordinates::deprecated="ResetCoordinates (last used in LevelScheme 3.21) has been absorbed into SetRegion.";
SchemePoints::deprecated="SchemePoints (last used in LevelScheme 3.21+ development version) has been absorbed into DataPlot.";
Scheme::deprecated="Scheme (last used in LevelScheme 3.21) has been replaced with Figure.";


LevelScheme::abovekinkx="The options AboveKinkL, AboveKinkR, and AboveKinkC (last used in LevelScheme 3.21) are no longer supported.  Please use SegmentL, SegmentR, and SegmentC instead.";


General::lsargs="Missing or unexpected arguments in level scheme object `1`.";
General::lsargsnull="One of the arguments in `1` is Null.  Check for extra commas among the arguments.";LevelScheme::notinscheme="Level scheme objects cannot be used outside of the function Scheme.  (If you are trying to save a list of level scheme objects for later use in a scheme, or to write a function which uses level scheme objects, use the SetDelayed symbol \":=\" for the assignment.)";
LevelScheme::notreentrant="Scheme is not reentrant.  It cannot be called within the object list given to Scheme.";
LevelScheme::badparam="Option `1` has invalid value `2`.";
LevelScheme::badvalue="An invalid value `2` has been encountered for `1`.";
LevelScheme::badlevel="A reference to an unrecognized level ID `1` has been encountered.";
LevelScheme::badpoint="A reference to an unrecognized point ID `1` has been encountered.";
LevelScheme::baddataset="A reference to an unrecognized dataset ID `1` has been encountered.";
SetScale::nonpositive="User axis scale setting `1` is not positive.";
SetRegion::nonpositive="User coordinate region setting `1` does not consist of positive intervals.";
Lev::energystr="A string `2` has been specified as the level energy for a level (`1`), but this string cannot be converted to a number.";
RawGraphics::empty="Empty graphics (Graphics[options___]) discarded.";
RawGraphics::multiarg="Graphics with extra argument (Graphics[_,nonoption,options___]) discarded.";
RawGraphics::badpoint="Encountered point coordinates (`1`) not a numerical pair or a valid Mathematica Scaled or Offset coordinate.";
ViewPort3D::prange="Option PlotRange cannot have value Automatic when AxisScaling specified.";
FigurePanel::badij="A bad {row,column} index pair `1` has been specified for FigurePanel.";
Scheme::prange="No value specified for option PlotRange.  Assuming default value {{0,1},{0,1}}.";
Scheme::freegraphics="A Mathematica graphics object was encountered among the objects in the list you gave to Scheme.  Did you wish the graphics to be displayed as part of the figure?  If so, enclose the graphics in RawGraphics (see LevelScheme user guide).  Otherwise Mathematica graphics objects (such as the output of plotting functions) are simply discarded by Scheme.";
Trans::twoautos="You cannot specify both initial and final horizontal positions as Automatic.";
General::args="Missing or unexpected arguments in `1`.  (Check for missing or extra commas among the arguments.)";
General::kinks="Kinks have been specified for an arrow type which does not support them.";
General::nullsegment="An arrow cannot contain a line segment of zero length (canvas coordinates `1`).";
General::fromvert="Position specified as FromTailVertical or FromHeadVertical on horizontal line segment.";
General::fromhoriz="Position specified as FromTailHorizontal or FromHeadHorizontal on vertical line segment.";
General::horizbevel="Cannot bevel tail of horizontal arrow.  (Set option TailBevel->False.)";
General::conversionlip="For conversion-electron arrows, it is recommended that HeadLip be set to 0, yielding a cornerless arrowhead.  Otherwise, a misleading plot is obtained, since the corner of the arrowhead is still shaded even for vanishing conversion coefficient.";
LaTeXTableEntryValue::notnumeric="LaTeX-style table entry `1` converts to `2`, which is not numeric.";
SchemeSquare::badr="Unrecognized radius specification format `1`.";SchemeCircle::badr="Unrecognized radius specification format `1`.";
Multipanel::oldsyntax="Old syntax (LevelScheme 2.0) used for Multipanel.  Assuming value None for tick lists.";
Multipanel::ambigticks="Ambiguous whether `1` specifies the tick values for a single axis, to be repeated, or several axes.";
Multipanel::num="Incorrect number of `1` given.";
Multipanel::autosizes="Cannot generate `1` automatically if any of `2` are Automatic.";
FigurePanel::undefined="FigurePanel[{row,column}] called when no multipanel plot defined.";
PanelLetter::nopanel="Cannot generate panel letter since not in multipanel plot.";
GrabPoints::noline="No line found in graphics.";
GrabPoints::manylines="More than one line found in graphics.  Only using first.";
DataPlot::baddata="Ignoring invalid data set (`1`) encountered in DataPlot.";
LimitX::badvalue="Nonnumerical x value in data point (`1`).";
LimitY::badvalue="Nonnumerical y value in data point (`1`).";
DataPlot::badsymbol="Symbol shape `1` unrecognized or improperly defined.  New symbols can be defined using DataSymbolShape.";


Begin["`Private`"];
$PrivateContext=$Context;


LegacyFilterOptions[f_Symbol,Opts___?OptionQ]:=Sequence@@FilterRules[{Opts},Options[f]];
LegacyRotate2D[{x_,y_},phi_,{x0_,y0_}]:=RotationTransform[-phi,{x0,y0}][{x,y}];
LegacyRotate2D[{x_,y_},phi_]:=LegacyRotate2D[{x,y},phi,{0,0}];
RotationMatrix3D[phi_,theta_,psi_]:=RotationMatrix[Pi-psi,{0,0,1}].RotationMatrix[theta,{1,0,0}].RotationMatrix[Pi-phi,{0,0,1}];
LegacyRegularPolygon[n_, rad_:1, ctr_:{0,0},tilt_:0, k_:1]:=Line[
Table[ctr+rad {Cos[t+tilt],Sin[t+tilt]}, {t, 0, 2Pi, 2Pi/n}][[NestList[Mod[#+k,n,1]&,1,n]]]
] ; 


Needs["LegacyGraphics`"]; 
Needs["BlockUnprotect`" ];


Print[
GridBox[
{
{"LevelScheme scientific figure preparation system"},
{"M. A. Caprio, Department of Physics, University of Notre Dame"},
{RowBox[{"Comput. Phys. Commun. ",textbf["171"],", 107 (2005)"}]},
{"Version "<>$RevisionString},
{
RowBox[{
ButtonBox[
StyleBox["View color palette",FontFamily->"Times"],
ButtonNote->"Named color palette",ButtonFunction->(NamedColorPalette[]&),Active->True,ButtonFrame->"DialogBox",ButtonExpandable->False,Evaluator->Automatic
],
MakeButtonForURL[StyleBox["Visit home page",FontFamily->"Times"],$HomePageURL,ButtonFrame->"DialogBox",ButtonExpandable->False]
}]
}
},
ColumnAlignments->Left
]//DisplayForm
];


$SchemeBackgroundLayer=0;
$SchemeDrawingLayer=1;
$SchemeBlankingLayer=2;
$SchemeTextLayer=3;


$InScheme=False;


OptionSymbols={
(* from LevelScheme *)
SchemeObject,Lev,ExtensionLine,Connector,Trans,ManualLabel,ScaledLabel,BandLabel,LevelLabel,SchemeBracket,
SchemeLine,SchemePoints,SchemePolygon,SchemeBox,SchemeSquare,SchemeCircle,SchemeEllipse,SchemeArrow,
RawGraphics,ViewPort3D,ScaledViewPort3D,
FigurePanel,ScaledFigurePanel,Multipanel,SchemeAxis,PanelLetter,
LineStyle,FillStyle,
AttachIndex,
DataPlot,DataTag,SaveDataStyle,SetDataStyle,DataLabel,DataTransformation,DataLine,DataSymbol,DataLegend,
(* external *)
LinTicks,LogTicks
};
OptionSymbols3D={
ManualLabel3D,SchemeLine3D,SchemeArrow3D,RawGraphics3D
};


BasicOpts={Show,Color,Opacity,Layer,ClipToRectangle};
OutlineOpts={ShowLine,LineColor,LineOpacity,Thickness,Dashing,DashingGap,DashingCorrection};
TickOutlineOpts={TickShowLine->Automatic,TickLineColor->Automatic,TickLineOpacity->Automatic,TickThickness->Automatic};
FillOpts={ShowFill,FillColor,FillOpacity};
BackgroundOpts={Background->None,BackgroundOpacity->1};
TextOpts={FontFamily,FontSize,FontWeight,FontSlant,FontTracking,FontColor,FontOpacity,BackgroundFontSizeFactor};
TickTextOpts={
TickFontFamily->Automatic,TickFontSize->Automatic,TickFontWeight->Automatic,TickFontSlant->Automatic,TickFontTracking->Automatic,TickFontColor->Automatic,TickFontOpacity->Automatic};
PanelLetterTextOpts={PanelLetterFontFamily->Automatic,PanelLetterFontSize->Automatic,PanelLetterFontWeight->Automatic,PanelLetterFontSlant->Automatic,PanelLetterFontTracking->Automatic,PanelLetterFontColor->Automatic,PanelLetterFontOpacity->Automatic};
PanelLetterOpts={ShowPanelLetter->True,PanelLetterOffset->Automatic,PanelLetterCorner->{-1,1},PanelLetterNudge->0,PanelLetterOrientation->Automatic,PanelLetterBackground->None};
LabLOpts={LabL->None,ShowLabL->True,OffsetL->Automatic,NudgeL->0,OrientationL->Automatic,BackgroundL->None};
LabROpts={LabR->None,ShowLabR->True,OffsetR->Automatic,NudgeR->0,OrientationR->Automatic,BackgroundR->None};
LabTOpts={LabT->None,ShowLabT->True,OffsetT->Automatic,NudgeT->0,OrientationT->Automatic,BackgroundT->None};
LabBOpts={LabB->None,ShowLabB->True,OffsetB->Automatic,NudgeB->0,OrientationB->Automatic,BackgroundB->None};
LabCOpts={LabC->None,ShowLabC->True,OffsetC->Automatic,NudgeC->0,OrientationC->Automatic,BackgroundC->None};
LabXOpts={LabX->None,ShowLabX->True,OffsetX->Automatic,NudgeX->0,OrientationX->Automatic,BackgroundX->None};
LabOpts={ShowText->True,Offset->Automatic,Nudge->0,Orientation->Automatic,Background->None};


InheritanceMode={TrapUninheritableOptions->True,TrapUnknownOptions->True};


$DefaultFontFamily=If[$SystemID=="Windows","Times New Roman","Times"];


DefineOptions[SchemeObject,
{
(* Overall color *)
Color->Black,
Opacity->1,

(* Outline *)
ShowLine->True, 
LineColor->Automatic,LineOpacity->Automatic,Thickness->1,Dashing->None,DashingGap->Automatic,DashingCorrection->True,

(* Fill *)
ShowFill->True, FillColor->Automatic,FillOpacity->Automatic,

(* Text *)
FontFamily->$DefaultFontFamily,FontSize->12,FontWeight->"Plain",FontSlant->"Plain",FontTracking ->"Plain",FontColor->Automatic,
FontOpacity->Automatic,
BackgroundFontSizeFactor->1.0,

(* General rendering *)
Show->True,
Layer->Automatic,
ClipToRectangle->True
},
InheritanceMode];


DefineOptions[Lev,{SchemeObject,Join[BasicOpts,OutlineOpts,TextOpts]},
{
(* Line geometry margin *)
Margin->0.1,
EnergyNudge->0,

(* Label control *)
LabLOpts,LabROpts,LabTOpts,LabBOpts,LabCOpts,
EnergyLabelFunction->Identity,

(* Gull wings *)
WingHeight->0,
WingRiseWidth->10,
WingTipWidth->30,
MakeWingL->True,
MakeWingR->True,

(* Layer override*)
LineToFront->False

},
InheritanceMode];


DefineOptions[ExtensionLine,{SchemeObject,Join[BasicOpts,OutlineOpts]},
{
(* Extension line endpoint coordinates *)
ToWing->True
},
InheritanceMode];


DefineOptions[Connector,{SchemeObject,Join[BasicOpts,OutlineOpts]},{},InheritanceMode];


DefineOptions[Trans,{SchemeObject,Join[BasicOpts,OutlineOpts,FillOpts,TextOpts]},
{
(* Arrow shape properties *)
ArrowType->LineArrow,
ArrowHalf->All,
Width ->5,
TailBevel->True,
ShaftLines->2,
SquiggleBuffer->2,
SquiggleWavelength->10,
SquiggleSide->Right,
PlotPoints->32,
HeadLength->9,
HeadLip->3,
Kink->None,
ShowTail->False,ShowHead->True,  

(* Conversion fill properties *)
ConversionColor->White,
ConversionSide->Right,
ConversionCoeff->None,

(* Label control *)
LabLOpts,PosnL->Automatic,BufferL->Automatic,AboveKinkL->False,SegmentL->Automatic,
LabROpts,PosnR->Automatic,BufferR->Automatic,AboveKinkR->False,SegmentR->Automatic,
LabCOpts,PosnC->Automatic,AboveKinkC->False,SegmentC->Automatic,
LabTOpts,PosnT->Automatic,

(* Endpoint coordinates when between levels *)
EndPositions->{0.5,0.5},
FromWing->False,ToWing->False
},
InheritanceMode];


DefineOptions[ManualLabel,{SchemeObject,Join[BasicOpts,TextOpts]},{LabOpts},InheritanceMode];
DefineOptions[ScaledLabel,{SchemeObject,Join[BasicOpts,TextOpts]},{LabOpts},InheritanceMode];
DefineOptions[BandLabel,{SchemeObject,Join[BasicOpts,TextOpts]},{LabOpts},InheritanceMode];
DefineOptions[LevelLabel,{SchemeObject,Join[BasicOpts,OutlineOpts,TextOpts]},
{
LabOpts,
(* Callout line control *)
CallOutVector->None,Gap->0 
},
InheritanceMode];


DefineOptions[
ManualLabel3D,
{SchemeObject,Join[BasicOpts,TextOpts]},
{
(* Label control *)
Offset->Automatic,(*Nudge->0,*)Orientation->Automatic,ShowText->True,Background->None
},
InheritanceMode
];


DefineOptions[SchemeLine,{SchemeObject,Join[BasicOpts,OutlineOpts,TextOpts]},
{
(* Arrow shape properties *)
HeadLength->9,
HeadLip->3,
ShowTail->False,ShowHead->False,  

(* Label control *)
LabLOpts,PosnL->Automatic,(*BufferL->Automatic,*)
LabROpts,PosnR->Automatic,(*BufferR->Automatic,*)
LabTOpts,PosnT->Automatic,BufferT->Automatic,
LabBOpts,PosnB->Automatic,BufferB->Automatic,
LabCOpts,PosnC->Automatic
},
InheritanceMode
];
DefineOptions[SchemePoints,{SchemeObject,Join[BasicOpts,OutlineOpts,FillOpts]},{SymbolSize->2.5,SymbolShape->"Circle",PlotPoints->16},InheritanceMode];DefineOptions[SchemePolygon,{SchemeObject,Join[BasicOpts,OutlineOpts,FillOpts]},{},InheritanceMode];
DefineOptions[SchemeCircle,{SchemeObject,Join[BasicOpts,OutlineOpts,FillOpts,TextOpts]},
{
(* Arrow shape properties *)
HeadLength->9,
HeadLip->3,
ShowTail->False,ShowHead->False,  

(* Label control *)
LabLOpts,LabROpts,LabTOpts,LabBOpts,LabCOpts,LabXOpts,BufferX->Automatic,PosnX->Automatic
},
InheritanceMode];
DefineOptions[SchemeEllipse,{SchemeObject,Join[BasicOpts,OutlineOpts,FillOpts,TextOpts]},
{
(* Plotting control *)
PlotPoints->90,

(* Arrow shape properties *)
HeadLength->9,
HeadLip->3,
ShowTail->False,ShowHead->False,  

(* Label control *)
LabLOpts,LabROpts,LabTOpts,LabBOpts,LabCOpts,LabXOpts,BufferX->Automatic,PosnX->Automatic
},
InheritanceMode];
DefineOptions[SchemeBox,{SchemeObject,Join[BasicOpts,OutlineOpts,FillOpts,TextOpts]},
{
(* Label control *)
LabLOpts,LabROpts,LabTOpts,LabBOpts,LabCOpts
},
InheritanceMode];
DefineOptions[SchemeSquare,{SchemeObject,Join[BasicOpts,OutlineOpts,FillOpts,TextOpts]},
{
(* Label control *)
LabLOpts,LabROpts,LabTOpts,LabBOpts,LabCOpts
},
InheritanceMode];
DefineOptions[SchemeArrow,{SchemeObject,Join[BasicOpts,OutlineOpts,FillOpts,TextOpts]},
{
(* Arrow shape properties -- default for TailBevel differs from Trans *)
ArrowType->LineArrow,
ArrowHalf->All,
Width ->5,
TailBevel->False,
ShaftLines->2,
SquiggleBuffer->2,
SquiggleWavelength->10,
SquiggleSide->Right,
PlotPoints->32,
HeadLength->9,
HeadLip->3,
Kink->None,
ShowTail->False,ShowHead->True,  

(* Conversion fill properties *)
ConversionColor->White,
ConversionSide->Right,
ConversionCoeff->None,

(* Label control *)
LabLOpts,PosnL->Automatic,BufferL->Automatic,AboveKinkL->False,SegmentL->Automatic,
LabROpts,PosnR->Automatic,BufferR->Automatic,AboveKinkR->False,SegmentR->Automatic,
LabCOpts,PosnC->Automatic,AboveKinkC->False,SegmentC->Automatic,
LabTOpts,PosnT->Automatic
},
InheritanceMode];
DefineOptions[SchemeBracket,
{SchemeObject,Join[BasicOpts,OutlineOpts,TextOpts]},
{
(* Arrowhead control *)
HeadLength->3,
HeadLip->3,

(* Label control *)
LabBOpts,PosnB->Automatic,BufferB->Automatic,
LabLOpts,PosnL->Automatic,BufferL->Automatic,
LabTOpts,PosnT->Automatic,BufferT->Automatic,
LabROpts,PosnR->Automatic,BufferR->Automatic
},
InheritanceMode];
DefineOptions[SchemeLine3D,{SchemeObject,Join[{Color,Opacity,Show},OutlineOpts]},
{
},
InheritanceMode];
DefineOptions[SchemeArrow3D,{SchemeObject,Join[{Color,Opacity,Show},OutlineOpts,TextOpts]},
{
(* Arrow shape properties *)
ArrowType->LineArrow,
HeadLength->0.1,
HeadLip->0.1,
ShowTail->False,ShowHead->True ,

(* Label control *)
LabCOpts,PosnC->Automatic
},
InheritanceMode];



DefineOptions[RawGraphics,{SchemeObject,{Color,Opacity,Thickness,Dashing,DashingGap,DashingCorrection,Show,Layer,ClipToRectangle}},{

(* UNDOCUMENTED *)
Debug->False

},
InheritanceMode];
DefineOptions[RawGraphics3D,{SchemeObject,{Color,Opacity,Thickness,Dashing,DashingGap,DashingCorrection,Show}},{

(* UNDOCUMENTED *)
Debug->False

},
InheritanceMode];
DefineOptions[ViewPort3D,{SchemeObject,{Show,Layer}},{

(* Fill control -- differs from Color/FillColor and ShowFill convention of other objects *)
BackgroundOpts,

(* Option control *)
BlockOptions->{},

(* 3D display options *)
EulerRotation->None,
AxisScaling->Automatic,
Complement[
Options[Graphics3D],Cases[Options[Graphics3D],x:(Background->_)]
],

(* UNDOCUMENTED *)
Debug->False

},
InheritanceMode];
DefineOptions[ScaledViewPort3D,{SchemeObject,{Show,Layer}},{

(* Fill control -- differs from Color/FillColor and ShowFill convention of other objects *)
BackgroundOpts,

(* Option control *)
BlockOptions->{},

(* 3D display options *)
EulerRotation->None,
AxisScaling->Automatic,
Complement[
Options[Graphics3D],Cases[Options[Graphics3D],x:(Background->_)]
],

(* UNDOCUMENTED *)
Debug->False

},
InheritanceMode];


DefineOptions[PanelLetter,{Order->Horizontal,First->"a",Format->{"(",")"}},InheritanceMode];
DefineOptions[FigurePanel,
{SchemeObject,Join[{Color,Opacity,Show,Layer},OutlineOpts,TextOpts]},
{PanelLetter,All},
{
(* Panel coordinate range *)
PlotRange->Automatic,
XPlotRange->Automatic,YPlotRange->Automatic,
ExtendRange->0,

(* Panel geometry adjustments -- in Multipanel array only *)
PanelShift->None,PanelAdjustments->None,

(* Fill control -- differs from Color/FillColor and ShowFill convention of other objects *)
BackgroundOpts,

(* Frame control *)
Frame->True,
ShowEdge->{True,True,True,True},

(* Label label control *)
LabBOpts,PosnB->Automatic,BufferB->Automatic,
LabLOpts,PosnL->Automatic,BufferL->Automatic,
LabTOpts,PosnT->Automatic,BufferT->Automatic,
LabROpts,PosnR->Automatic,BufferR->Automatic,
FrameLabel->Automatic,
ShowFrameLabels->{True,True,True,True},

(* Panel letter control *)
PanelLetter->None,
PanelLetterInset->{15,15},
PanelLetterTextOpts,
PanelLetterOpts,

(* Frame ticks *)
FrameTicks->None,
ShowTicks->{True,True,True,True},
ShowTickLabels->{True,True,True,True},
TickNudge->{0,0,0,0},
TickTextOpts,
TickOutlineOpts

},
InheritanceMode];
DefineOptions[ScaledFigurePanel,
{SchemeObject,Join[{Color,Opacity,Show,Layer},OutlineOpts,TextOpts]},
{PanelLetter,All},
{
(* Panel coordinate range *)
PlotRange->Automatic,
XPlotRange->Automatic,YPlotRange->Automatic,
ExtendRange->0,

(* Panel geometry adjustments -- in Multipanel array only *)
(* not applicable to ScaledPanel *)

(* Fill control -- differs from Color/FillColor and ShowFill convention of other objects *)
BackgroundOpts,

(* Frame control *)
Frame->True,
ShowEdge->{True,True,True,True},

(* Label label control *)
LabBOpts,PosnB->Automatic,BufferB->Automatic,
LabLOpts,PosnL->Automatic,BufferL->Automatic,
LabTOpts,PosnT->Automatic,BufferT->Automatic,
LabROpts,PosnR->Automatic,BufferR->Automatic,
FrameLabel->Automatic,
ShowFrameLabels->{True,True,True,True},

(* Panel letter control *)
PanelLetter->None,
PanelLetterInset->{15,-15},
PanelLetterTextOpts,
PanelLetterOpts,

(* Frame ticks *)
FrameTicks->None,
ShowTicks->{True,True,True,True},
ShowTickLabels->{True,True,True,True},
TickNudge->{0,0,0,0},
TickTextOpts,
TickOutlineOpts

},
InheritanceMode];
DefineOptions[Multipanel,
{FigurePanel,
Complement[First/@Options[FigurePanel],{PlotRange,XPlotRange,YPlotRange,LabB,LabL,LabT,LabR,FrameLabel,FrameTicks,PanelLetter}]
},
{

(* Geometry *)
XPanelSizes->1,YPanelSizes->1,
XGapSizes->0,YGapSizes->0,
XMarginSizes->0,YMarginSizes->0,
Margin->0,

(* Panel appearance *)
XPlotRanges->Automatic,YPlotRanges->Automatic,
XFrameLabels->None,YFrameLabels->None,
XFrameTicks->Automatic,YFrameTicks->Automatic,
ShowFrameLabelsExterior->{True,True,False,False},
ShowFrameLabelsInterior->{False,False,False,False},
ShowTickLabelsExterior->{True,True,False,False},
ShowTickLabelsInterior->{False,False,False,False}
},
InheritanceMode];
DefineOptions[SchemeAxis,
{SchemeObject,Join[BasicOpts,OutlineOpts,TextOpts]},
{
(* Arrowhead control *)
ShowHead->True,
HeadLength->9,
HeadLip->3,

(* Label control *)
LabBOpts,PosnB->Automatic,BufferB->Automatic,
LabLOpts,PosnL->Automatic,BufferL->Automatic,
LabTOpts,PosnT->Automatic,BufferT->Automatic,
LabROpts,PosnR->Automatic,BufferR->Automatic,

(* Frame ticks *)
Ticks->None,
ShowTicks->True,
ShowTickLabels->True,
TickNudge->0,
TickTextOpts,
TickOutlineOpts

},
InheritanceMode];


DefineOptions[AttachIndex,{Range->Automatic,First->1,ScaleFactor->1},InheritanceMode];


DefineOptions[DataPlot,{ShowData->True,Debug->False},InheritanceMode];
DefineOptions[DataTag,{},InheritanceMode];
DefineOptions[SaveDataStyle,{Debug->False},InheritanceMode];
DefineOptions[SetDataStyle,{Debug->False},InheritanceMode];
DefineOptions[DataLabel,{SchemeObject,Join[BasicOpts,TextOpts]},
{
LabLOpts,PosnL->Automatic,
LabROpts,PosnR->Automatic,
LabTOpts,PosnT->Automatic,BufferT->Automatic,
LabBOpts,PosnB->Automatic,BufferB->Automatic,
LabCOpts,PosnC->Automatic
},
InheritanceMode];


DefineOptions[DataLine,{SchemeObject,Join[BasicOpts,OutlineOpts]},{LineShape->"Straight",PlotPoints->3},InheritanceMode];
DefineOptions[DataSymbol,{SchemeObject,Join[BasicOpts,OutlineOpts,FillOpts]},{SymbolSize->2.5,SymbolShape->"Circle",PlotPoints->16},InheritanceMode];
DefineOptions[DataTransformation,{DataFilters->None},InheritanceMode];


DefineOptions[DataLegend,{SchemeObject,Join[BasicOpts,OutlineOpts,FillOpts,TextOpts]},
{LabOpts,Length->10,Gap->5,LineSpacing->1.1},
InheritanceMode];


DefineOptions[Figure,{SchemeObject,Join[{Color,Opacity},{LineColor,LineOpacity,Thickness,Dashing,DashingGap,DashingCorrection},{FontFamily,FontSize,FontWeight,FontSlant,FontTracking,FontColor,FontOpacity}]},
{
(* inherited outline and text options control frame line and labels but not frame ticks *)

(* Plot region control *)
PlotRange->Automatic,
ExtendRange->0,
ImageSize->Automatic,

(* Axes and frame control *)
Frame->False,
FrameLabel->Automatic,
LabB->None,LabL->None,LabT->None,LabR->None,
Axes->False,

(* Tick control *)
FrameTicks->None,
Ticks->None,
TickTextOpts,
(* TickOutlineOpts not supported *)

(* Rendering properties *)
Background->None,  (* BackgroundOpacity not supported *)
DisplayFunction->$DisplayFunction,

(* Option control *)
BlockOptions->{},

(* Conditional inclusion *)
SchemeFlags->{},

(* UNDOCUMENTED debugging options *)
Information->False,
Debug->False

}
];


DefineOptions[LineStyle,{SchemeObject,{Color,Opacity,LineColor,LineOpacity,Thickness,Dashing,DashingGap,DashingCorrection}},
{},
InheritanceMode];
DefineOptions[FillStyle,{SchemeObject,{Color,Opacity,FillColor,FillOpacity}},
{},
InheritanceMode];


CoordinateSystems={CanvasCoords,AbsoluteCoords,RegionCoords,ScaledCoords,UserCoords};
CoordinateSystemAbbreviation[CanvasCoords]="C";
CoordinateSystemAbbreviation[AbsoluteCoords]="A";
CoordinateSystemAbbreviation[RegionCoords]="R";
CoordinateSystemAbbreviation[ScaledCoords]="S";
CoordinateSystemAbbreviation[UserCoords]="U";
CoordinateSystemQ[SystemA_]:=MemberQ[CoordinateSystems,SystemA];


Hold[LevelScheme`Coord`CoordA];  
Hold[LevelScheme`Coord`CoordB]; 
If[!ValueQ[ConversionFunctionSymbols],
ConversionFunctionSymbols=HoldPattern/@ToExpression/@Flatten[
TableForEach[
{
"LevelScheme`Coord`"<>"P"<>CoordinateSystemAbbreviation[SystemG]<>"Of"<>"P"<>CoordinateSystemAbbreviation[SystemF],
"LevelScheme`Coord`"<>"X"<>CoordinateSystemAbbreviation[SystemG]<>"Of"<>"X"<>CoordinateSystemAbbreviation[SystemF],
"LevelScheme`Coord`"<>"Y"<>CoordinateSystemAbbreviation[SystemG]<>"Of"<>"Y"<>CoordinateSystemAbbreviation[SystemF],
"LevelScheme`Coord`"<>"DP"<>CoordinateSystemAbbreviation[SystemG]<>"Of"<>"P"<>CoordinateSystemAbbreviation[SystemF],
"LevelScheme`Coord`"<>"DX"<>CoordinateSystemAbbreviation[SystemG]<>"Of"<>"X"<>CoordinateSystemAbbreviation[SystemF],
"LevelScheme`Coord`"<>"DY"<>CoordinateSystemAbbreviation[SystemG]<>"Of"<>"Y"<>CoordinateSystemAbbreviation[SystemF]
},
{SystemF,CoordinateSystems},{SystemG,CoordinateSystems}
]
]
];
AppendTo[$ContextPath,"LevelScheme`Coord`"];


ConvertCoordinate[SystemF_?CoordinateSystemQ,SystemG_?CoordinateSystemQ,Type:C,PF:{_,_}]:=CoordA[SystemF,SystemG]+CoordB[SystemF,SystemG]*PF;
ConvertCoordinate[SystemF_?CoordinateSystemQ,SystemG_?CoordinateSystemQ,Type:D,PF:{_,_}]:=CoordB[SystemF,SystemG]*PF;
ConvertCoordinate[SystemF_?CoordinateSystemQ,SystemG_?CoordinateSystemQ,Type:C,x_,Index:(1|2)]:=CoordA[SystemF,SystemG][[Index]]+CoordB[SystemF,SystemG][[Index]]*x;
ConvertCoordinate[SystemF_,SystemG_,Type:D,x_,Index:(1|2)]:=CoordB[SystemF,SystemG][[Index]]*x;


ConvertCoordinate[SystemF_?CoordinateSystemQ,SystemG_?CoordinateSystemQ,Type:(C|D),{RF1:{_,_},RF2:{_,_}}]:={ConvertCoordinate[SystemF,SystemG,Type,RF1,1],ConvertCoordinate[SystemF,SystemG,Type,RF2,2]};
ConvertCoordinate[SystemF_?CoordinateSystemQ,SystemG_?CoordinateSystemQ,Type:(C|D),RF:{_,_},Index:(1|2)]:=ConvertCoordinate[SystemF,SystemG,Type,#,Index]&/@RF;


ConvertRange[SystemF_?CoordinateSystemQ,SystemG_?CoordinateSystemQ,Type:(C|D),RF:{_?NumericQ,_?NumericQ},Index:(1|2)]:=Map[(ConvertCoordinate[SystemF,SystemG,Type,#,Index]&),RF];
ConvertRegion[SystemF_?CoordinateSystemQ,SystemG_?CoordinateSystemQ,Type:(C|D),RF:{{_?NumericQ,_?NumericQ},{_?NumericQ,_?NumericQ}}]:=MapIndexed[(ConvertRange[SystemF,SystemG,Type,#1,First[#2]]&),RF];


SavePoint[ID_,P:{_?NumericQ,_?NumericQ},GivenSystem:(_?CoordinateSystemQ):UserCoords]:=Module[
{},

CheckInScheme[];
CheckValue[ID,_?LevelIdentifierQ,"a point identifier symbol (cannot be list or number)"];
LevelScheme`Data`P[ID]=ConvertCoordinate[GivenSystem,CanvasCoords,C,P];

];
GetPoint[ID_,GivenSystem:(_?CoordinateSystemQ):UserCoords]:=Module[
{},

CheckInScheme[];
CheckPoint[ID];
ConvertCoordinate[CanvasCoords,GivenSystem,C,LevelScheme`Data`P[ID]]
];


DefineCoordinates[AbsSize_List,P1C_List,P2C_List,P3C_List,P4C_List,P3R_List,P4R_List,AUR_List,BUR_List]:=Module[
{SystemF,SystemG,FunctionNameStrings,P,X,Y},

(* define conversion constants to canvas system *)
CoordA[CanvasCoords,CanvasCoords]={0.,0.};
CoordB[CanvasCoords,CanvasCoords]={1.,1.};
CoordA[AbsoluteCoords,CanvasCoords]=P1C;
CoordB[AbsoluteCoords,CanvasCoords]=(P2C-P1C)/AbsSize;
CoordA[RegionCoords,CanvasCoords]=P3C-P3R*(P4C-P3C)/(P4R-P3R);
CoordB[RegionCoords,CanvasCoords]=(P4C-P3C)/(P4R-P3R);
CoordA[ScaledCoords,CanvasCoords]=P3C;
CoordB[ScaledCoords,CanvasCoords]=P4C-P3C;
CoordA[UserCoords,CanvasCoords]=P3C+(AUR-P3R)*(P4C-P3C)/(P4R-P3R);
CoordB[UserCoords,CanvasCoords]=BUR*(P4C-P3C)/(P4R-P3R);

(* deduce conversion constants to any other system *)
DoForEach[
CoordA[SystemF,SystemG]=(CoordA[SystemF,CanvasCoords]-CoordA[SystemG,CanvasCoords])/CoordB[SystemG,CanvasCoords];
CoordB[SystemF,SystemG]=CoordB[SystemF,CanvasCoords]/CoordB[SystemG,CanvasCoords],
{SystemF,CoordinateSystems},{SystemG,Complement[CoordinateSystems,{CanvasCoords}]}
];

(* define private shorthand operators *)
Evaluate[ConversionFunctionSymbols]=
SuppressMessage[Part::partd,
Flatten[
TableForEach[
{
Compile[{{P,_Real,1}},Evaluate[ConvertCoordinate[SystemF,SystemG,C,{P[[1]],P[[2]]}]]],
Compile[{X},Evaluate[ConvertCoordinate[SystemF,SystemG,C,X,1]]],
Compile[{Y},Evaluate[ConvertCoordinate[SystemF,SystemG,C,Y,2]]],
Compile[{{P,_Real,1}},Evaluate[ConvertCoordinate[SystemF,SystemG,D,{P[[1]],P[[2]]}]]],
Compile[{X},Evaluate[ConvertCoordinate[SystemF,SystemG,D,X,1]]],
Compile[{Y},Evaluate[ConvertCoordinate[SystemF,SystemG,D,Y,2]]]
},
{SystemF,CoordinateSystems},{SystemG,CoordinateSystems}
]
]

];

];


DXCTick:=(DXCOfXA[$TickScaleFactor*#]&);
DYCTick:=(DYCOfYA[$TickScaleFactor*#]&);


SetOrigin[{x_?NumericQ,y_?NumericQ}]:=Module[{},
$AUR={x,y};
DefineCoordinates[$AbsSize,$P1C,$P2C,$P3C,$P4C,$P3R,$P4R,$AUR,$BUR];
Null
];
SetOrigin[x_?NumericQ]:=SetOrigin[{x,0}];
SetOrigin[]:=SetOrigin[{0,0}];


SetScale[{x_?NumericQ,y_?NumericQ}]:=Module[{},
$BUR={x,y};
If[!Positive[Min[$BUR]],ErrorMessage[SetScale::nonpositive,$BUR]];
DefineCoordinates[$AbsSize,$P1C,$P2C,$P3C,$P4C,$P3R,$P4R,$AUR,$BUR];
Null
];
SetScale[y_?NumericQ]:=SetScale[{1,y}];
SetScale[]:=SetScale[{1,1}];


SetRegion[{{x3C_?NumericQ,x4C_?NumericQ},{y3C_?NumericQ,y4C_?NumericQ}},{{x3R_?NumericQ,x4R_?NumericQ},{y3R_?NumericQ,y4R_?NumericQ}}]:=Module[
{Differences},
$RegionRange={{x3C,x4C},{y3C,y4C}};
$P3C={x3C,y3C};$P4C={x4C,y4C};
$P3R={x3R,y3R};$P4R={x4R,y4R};
$AUR={0,0};$BUR={1,1};
Differences=-Subtract@@@$RegionRange;
If[!Positive[Min[Differences]],ErrorMessage[SetRegion::nonpositive,$RegionRange]];
DefineCoordinates[$AbsSize,$P1C,$P2C,$P3C,$P4C,$P3R,$P4R,$AUR,$BUR];
Null
];
SetRegion[]:=($Background=None;SetRegion[$CanvasRange,$CanvasRange]);


SetAttributes[ListableNot,Listable];
ListableNot[Args___]:=Not[Args];
SetAttributes[ListableAnd,Listable];
ListableAnd[Args___]:=And[Args];
SetAttributes[ListableOr,Listable];
ListableOr[Args___]:=Or[Args];
SetAttributes[ListableXor,Listable];
ListableXor[Args___]:=Xor[Args];


VectorArcTan[{x_?NumericQ,y_?NumericQ}]:=If[{x,y}=={0,0},0.,ArcTan[x,y]];
VectorLength[{x_?NumericQ,y_?NumericQ}]:=Sqrt[x^2+y^2];


SegmentArcTan[{X1_List,X2_List}]:=VectorArcTan[X2-X1];
SegmentLength[{X1_List,X2_List}]:=VectorLength[X2-X1];


Interpolate[x1_,x2_,y1_,y2_,x_]:=y1+(x-x1)/(x2-x1)*(y2-y1);


InRange[{x1_,x2_},x_]:=(x1<=x)&&(x<=x2);


InRegion[{{x1_,x2_},{y1_,y2_}},{x_,y_}]:=InRange[{x1,x2},x]&&InRange[{y1,y2},y];
InRegion[{x1_,y1_},{x2_,y2_},{x_,y_}]:=InRange[{x1,x2},x]&&InRange[{y1,y2},y];


ExtendRange[PRange:{x1_?NumericQ,x2_?NumericQ},PFrac:{fx1_?NumericQ,fx2_?NumericQ}]:=PRange+PFrac*{-1,+1}*-Subtract@@PRange;
ExtendRange[PRange:{x1_?NumericQ,x2_?NumericQ},fx_]:=ExtendRange[PRange,{fx,fx}];


ExtendRegion[PRange:{{x1_?NumericQ,x2_?NumericQ},{y1_?NumericQ,y2_?NumericQ}},PFrac:{{fx1_?NumericQ,fx2_?NumericQ},{fy1_?NumericQ,fy2_?NumericQ}}]:=PRange+PFrac*{{-1,+1},{-1,+1}}*-Subtract@@@PRange;
ExtendRegion[PRange:{{x1_?NumericQ,x2_?NumericQ},{y1_?NumericQ,y2_?NumericQ}},{fx_?NumericQ,fy_?NumericQ}]:=ExtendRegion[PRange,{{fx,fx},{fy,fy}}];
ExtendRegion[PRange:{{x1_?NumericQ,x2_?NumericQ},{y1_?NumericQ,y2_?NumericQ}},f_?NumericQ]:=ExtendRegion[PRange,{f,f}];


RealNumericQ=((#===-Infinity)||(#===+Infinity)||Head[N[#]]===Real&);


SetAttributes[SuppressMessage,HoldAll];
SuppressMessage[MessageID_,Body_]:=Module[
{WasOn,Value},
WasOn=Switch[
Head[MessageID],
String|MessageName,True,
$Off,False
];
Off[MessageID];
Value=Body;
If[WasOn,On[MessageID]];
Value
];


UpgradeScalarX[P_]:=Switch[P,
_?NumericQ,{P,0},
{_?NumericQ,_?NumericQ},P
];
UpgradeScalarY[P_]:=Switch[P,
_?NumericQ,{0,P},
{_?NumericQ,_?NumericQ},P
];
UpgradeScalarXY[P_]:=Switch[P,
_?NumericQ,{P,P},
{_?NumericQ,_?NumericQ},P
];


MarginQ[(_?NumericQ)|{_?NumericQ,_?NumericQ}|{{_?NumericQ,_?NumericQ},{_?NumericQ,_?NumericQ}}]:=True;
MarginQ[_]:=False;


UpgradeMargin[xy_?NumericQ]:=UpgradeMargin[{xy,xy}];
UpgradeMargin[{x_?NumericQ,y_?NumericQ}]:=UpgradeMargin[{{x,x},{y,y}}];
UpgradeMargin[{{x1_?NumericQ,x2_?NumericQ},{y1_?NumericQ,y2_?NumericQ}}]:={{x1,x2},{y1,y2}};


AugmentList[NumEntries_Integer,L_List,Filler_]:=Join[L,Table[Filler,{NumEntries-Length[L]}]];


Options[Intersperse]={First->False,Last->False};
Intersperse[L_List,Separator_,Opts___?OptionQ]:=Module[
{FullOpts=Flatten[{Opts,Options[Intersperse]}]},
Insert[
L,
Separator,
Table[{i},{i,If[First/.FullOpts,1,2],If[Last/.FullOpts,Length[L]+1,Length[L]]}]
]
];
Intersperse[Item_,Separator_,Num_Integer?NonNegative,Opts___?OptionQ]:=Intersperse[Table[Item,{Num}],Separator,Opts];


SingleRadiusQ[P_]:=MatchQ[P,_?NumericQ|Horizontal[_?NumericQ]|Vertical[_?NumericQ]|Point[_?NumericQ]];
DoubleRadiusQ[P_]:=MatchQ[P,{_?NumericQ,_?NumericQ}|Horizontal[{_?NumericQ,_?NumericQ}]|Vertical[{_?NumericQ,_?NumericQ}]|Point[{_?NumericQ,_?NumericQ}]];
RadiusQ[P_]:=SingleRadiusQ[P]||DoubleRadiusQ[P];


ConvertRadiusToCanvas[R_?RadiusQ]:=Switch[
R,
_?NumericQ|{_?NumericQ,_?NumericQ},
DPCOfPU@UpgradeScalarXY[R],
Horizontal[_?NumericQ|{_?NumericQ,_?NumericQ}],
DPCOfPA@(DXAOfXU/@UpgradeScalarXY[First[R]]),
Vertical[_?NumericQ|{_?NumericQ,_?NumericQ}],
DPCOfPA@(DYAOfYU/@UpgradeScalarXY[First[R]]),
Point[_?NumericQ|{_?NumericQ,_?NumericQ}],
DPCOfPA@UpgradeScalarXY[First[R]]
];


SetAttributes[ErrorMessage,HoldFirst];
ErrorMessage[Args___]:=Module[
{},
Message[Args];
If[
LevelScheme`Private`$InScheme,
Throw[$ErrorFlag],
Abort[]
]
];


SetAttributes[CatchError,HoldAll];
CatchError[Body_]:=(Catch[Body]===$ErrorFlag);


CheckInScheme[]:=Module[
{},
If[LevelScheme`Private`$InScheme=!=True,
Message[LevelScheme::notinscheme];
Abort[]
]
];


SetAttributes[FallThroughError,HoldAll];
FallThroughError[Object_Symbol,Expr_]:=Module[
{},
CheckInScheme[];
If[
Count[Hold[Expr],Null,{2}]>0,
Message[Object::lsargsnull,HoldForm[Expr]]
];
ErrorMessage[Object::lsargs,HoldForm[Expr]]
];


CheckOption[Param_,TestPattern_,FullOpts_List]:=Module[
{},
If[
!MatchQ[Param/.FullOpts,TestPattern],
ErrorMessage[LevelScheme::badparam,Param,Param/.FullOpts]
]
];
CheckValue[Value_,TestPattern_,Description_String]:=Module[
{},
If[
!MatchQ[Value,TestPattern],
ErrorMessage[LevelScheme::badvalue,Description,Value]
]
];


CheckLevel[ID_]:=Module[
{},
If[
!NumericQ[LevelScheme`Data`UserEnergy[ID]],
ErrorMessage[LevelScheme::badlevel,ID]
]
];


CheckPoint[ID_]:=Module[
{},
If[
!VectorQ[LevelScheme`Data`P[ID]],
ErrorMessage[LevelScheme::badpoint,ID]
]
];


CheckDataSet[ID_]:=Module[
{},
If[
!TrueQ[LevelScheme`Data`DataTagDefined[ID]],
ErrorMessage[LevelScheme::baddataset,ID]
]
];


LevelIdentifierQ[Expr_]:=((Head[Expr]=!=List)&&!NumericQ[Expr]);


ColorDirectivePattern=(_GrayLevel|_RGBColor|_Hue|_CMYKColor); 


CorrectedDash[Thickness_][Length_,{(Index_Integer)?OddQ}]:=Max[Length-Thickness,0.];
CorrectedDash[Thickness_][Length_,{(Index_Integer)?EvenQ}]:=Max[Length+Thickness,0.];
MakeOutlineDirectives[FullOpts_List] :=Module[
{DashLengths,DefaultGapLength,DefaultGapFactor},
CheckOption[Color,ColorDirectivePattern,FullOpts];
CheckOption[Opacity,_?NumericQ,FullOpts];
CheckOption[LineColor,Automatic|ColorDirectivePattern,FullOpts];
CheckOption[LineOpacity,Automatic|_?NumericQ,FullOpts];
CheckOption[Thickness,_?NumericQ,FullOpts];
CheckOption[Dashing,None|Automatic|True|(_?NumericQ)|{(_?NumericQ)...}|AbsoluteDashing[{(_?NumericQ)...}],FullOpts];
CheckOption[DashingGap,Automatic|(_?NumericQ),FullOpts];
CheckOption[DashingCorrection,True|False,FullOpts];

DefaultGapFactor=1/2;
DefaultGapLength=GetAutoOption[
DashingGap,
Switch[
(Dashing/.FullOpts),
None|0|_AbsoluteDashing,None,
Automatic|True,DefaultGapFactor*4,
_?NumericQ,DefaultGapFactor*(Dashing/.FullOpts),
{(_?NumericQ)...},DefaultGapFactor*Plus@@(Dashing/.FullOpts)/Length[(Dashing/.FullOpts)],
_AbsoluteDashing,None
],
FullOpts
];
DashLengths=Switch[
Dashing/.FullOpts,
None|0,{},
Automatic|True,{4,DefaultGapLength},
_?NumericQ,{(Dashing/.FullOpts),DefaultGapLength},
{(_?NumericQ)...},Intersperse[(Dashing/.FullOpts),DefaultGapLength,Last->True],
_AbsoluteDashing,First[Dashing/.FullOpts]
];
DashLengths=MapIndexed[
CorrectedDash[If[(DashingCorrection/.FullOpts),(Thickness/.FullOpts),0]],
DashLengths
];

{

GetAutoOption[LineColor,Color/.FullOpts,FullOpts],
Opacity[GetAutoOption[LineOpacity,Opacity/.FullOpts,FullOpts]],
AbsoluteThickness[Thickness/.FullOpts],
AbsoluteDashing[DashLengths]

}
];

MakeOutline[Art_,Opts___?OptionQ] := Module[
{
FullOpts=Flatten[{Opts}],
CroppedArt
},

CheckOption[Show,True|False,FullOpts];
CheckOption[ShowLine,True|False,FullOpts];
CheckOption[Layer,Automatic|_?NumericQ,FullOpts];
CheckOption[ClipToRectangle,True|False,FullOpts];

If[(Show/.FullOpts)&&(ShowLine/.FullOpts),
CroppedArt=If[
ClipToRectangle/.FullOpts,
First@ClipToRectangle[$RegionRange,Graphics[Art]],
Art
];
SchemeGraphics[
MakeOutlineDirectives[FullOpts],
CroppedArt,
GetAutoOption[Layer,$SchemeDrawingLayer,FullOpts]
]
]
];


MakeOutline3D[Art_,Opts___?OptionQ] := Module[
{
FullOpts=Flatten[{Opts}]
},

CheckOption[ShowLine,True|False,FullOpts];

If[
(Show/.FullOpts)&&(ShowLine/.FullOpts),
Graphics3D[Flatten[{
MakeOutlineDirectives[FullOpts],
Art
}]]
]
];


MakeFillDirectives[FullOpts_List] := 
{
CheckOption[Color,ColorDirectivePattern,FullOpts];
CheckOption[Opacity,_?NumericQ,FullOpts];
CheckOption[FillColor,Automatic|ColorDirectivePattern,FullOpts];
CheckOption[FillOpacity,Automatic|_?NumericQ,FullOpts];

GetAutoOption[FillColor,Color/.FullOpts,FullOpts],
Opacity[GetAutoOption[FillOpacity,Opacity/.FullOpts,FullOpts]]

};

MakeFill[Art_,Opts___?OptionQ] :=  Module[
{
FullOpts=Flatten[{Opts}],
CroppedArt
},

CheckOption[Show,True|False,FullOpts];
CheckOption[ShowFill,True|False,FullOpts];
CheckOption[Layer,Automatic|_?NumericQ,FullOpts];
CheckOption[ClipToRectangle,True|False,FullOpts];

If[(Show/.FullOpts)&&(ShowFill/.FullOpts),
CroppedArt=If[
ClipToRectangle/.FullOpts,
First@ClipToRectangle[$RegionRange,Graphics[Art]],
Art
];
SchemeGraphics[
MakeFillDirectives[FullOpts],
CroppedArt,
GetAutoOption[Layer,$SchemeDrawingLayer,FullOpts]
]
]
];


MakeTextStyle[FullOpts_List] := Module[
{},

CheckOption[Color,ColorDirectivePattern,FullOpts];
CheckOption[Opacity,_?NumericQ,FullOpts];
CheckOption[FontColor,Automatic|ColorDirectivePattern,FullOpts];
CheckOption[FontOpacity,Automatic|(_?NumericQ),FullOpts];
CheckOption[FontSize,_?NumericQ,FullOpts];

{
FontFamily ->(FontFamily/.FullOpts),FontSize->(FontSize/.FullOpts),FontSlant->(FontSlant/.FullOpts),FontTracking->(FontTracking/.FullOpts),FontWeight->(FontWeight/.FullOpts),FontColor->GetAutoOption[FontColor,Color/.FullOpts,FullOpts],
FontOpacity->GetAutoOption[FontOpacity,Opacity/.FullOpts,FullOpts],
ShowAutoStyles->False
}
];

MakeTextOrientation[OrientationOption_,theta_]:=Module[
{
},

(* Chop[] is necessary to make sure straight-down labels by default have their bottom to the right, like for labels to the left of straight down. *)

Switch[OrientationOption,
Automatic,
+(Sign[Chop[Cos[theta]]]-KroneckerDelta[Sign[Chop[Cos[theta]]]])*{Cos[theta],Sin[theta]},
Inverted,
-(Sign[Cos[theta]]-KroneckerDelta[Sign[Cos[theta]]])*{Cos[theta],Sin[theta]},
Horizontal,
{1,0},
Vertical,
{0,1},
_?NumericQ,
{Cos[OrientationOption],Sin[OrientationOption]},
_List,
OrientationOption
]
];

MakeText[Art_,Posn_,DefaultAngle_,Opts___?OptionQ] :=  Module[
{
FullOpts=Flatten[{Opts}],
CalculatedOffset,
CalculatedPosn,
CalculatedOrientation,
StyleList,
OptOffset,
OptNudge,
OptBackground,
IsInRegion
},

CheckOption[Show,True|False,FullOpts];
CheckOption[ShowText,True|False,FullOpts];
CheckOption[ClipToRectangle,True|False,FullOpts];

OptOffset=(Offset/.FullOpts);
OptNudge=(Nudge/.FullOpts);
OptBackground=GetAutoOption[Background,If[$Background===None,Automatic,$Background],FullOpts];

(* Calculate properties *)
CalculatedOffset=OptOffset;
CalculatedPosn=Posn+DPCOfPA[UpgradeScalarY[OptNudge]];
CalculatedOrientation=MakeTextOrientation[(Orientation/.FullOpts) ,DefaultAngle];
StyleList=MakeTextStyle[FullOpts];
IsInRegion=InRegion[$RegionRange,Posn];

If[(Show/.FullOpts)&&(ShowText/.FullOpts)&&(Art=!=None),If[IsInRegion||!(ClipToRectangle/.FullOpts),
{

(* background block *)

(* Note: If FontSize is specified in TextStyle option to Text[], then background box can still shrink horizontally but can never shrink below the font's height (with generous margins), whether adjusted with an AdjustmentBox or set in a different font size using they StyleBox.  Vertical height seems not to shrink much in general for smaller fonts. *)

If[(OptBackground=!=None),
SchemeGraphics[
{},
{Text[
DisplayForm[StyleBox[Art,FontSize->(BackgroundFontSizeFactor/.FullOpts)*(FontSize/.FullOpts),ShowContents->False]],
CalculatedPosn,
CalculatedOffset,
CalculatedOrientation,
BaseStyle->StyleList,
Background->OptBackground
]},
GetAutoOption[Layer,$SchemeBlankingLayer,FullOpts]
]
],

(* text itself *)

SchemeGraphics[
{},
{Text[
DisplayForm[Art],
CalculatedPosn,
CalculatedOffset,
CalculatedOrientation,
BaseStyle->StyleList
]},
GetAutoOption[Layer,$SchemeTextLayer,FullOpts]
]
}
]
]

];


MakeText3D[Art_,Posn_,DefaultAngle_,Opts___?OptionQ] :=  Module[
{
FullOpts=Flatten[{Opts}],
CalculatedOffset,
CalculatedPosn,
CalculatedOrientation,
StyleList,
OptBackground
},

CheckOption[Show,True|False,FullOpts];
CheckOption[ShowText,True|False,FullOpts];

OptBackground=(Background/.FullOpts);

(* Calculate properties *)
CalculatedOffset=(Offset/.FullOpts);
CalculatedPosn=Posn;
CalculatedOrientation=MakeTextOrientation[(Orientation/.FullOpts) ,DefaultAngle];
StyleList=MakeTextStyle[FullOpts];

Graphics3D[
Flatten[{

(* background block *)

(* Note: If FontSize is specified in TextStyle option to Text[], then background box can still shrink horizontally but can never shrink below the font's height (with generous margins), whether adjusted with an AdjustmentBox or set in a different font size using they StyleBox.  Vertical height seems not to shrink much in general for smaller fonts. *)

If[(Show/.FullOpts)&&(ShowText/.FullOpts)&&(Art=!=None)&&(OptBackground=!=None),
{
Text[
(*StyleBox[AdjustmentBox[Art,BoxMargins->$BackgroundMargins],ShowContents->False]//DisplayForm,*)
DisplayForm[StyleBox[Art,FontSize->(BackgroundFontSizeFactor/.FullOpts)*(FontSize/.FullOpts),ShowContents->False]],
CalculatedPosn,
CalculatedOffset,
CalculatedOrientation,
BaseStyle->StyleList,
Background->OptBackground
]
},
{}
],

(* text itself *)
If[(Show/.FullOpts)&&(ShowText/.FullOpts)&&(Art=!=None),
{Text[
DisplayForm[Art],
CalculatedPosn,
CalculatedOffset,
CalculatedOrientation,
BaseStyle->StyleList
]},
{}
]

}]
]

];


MakeRawGraphicsDirectives[FullOpts_List] :=Module[
{},

CheckOption[Color,ColorDirectivePattern,FullOpts];
CheckOption[Opacity,_?NumericQ,FullOpts];

MakeOutlineDirectives[Join[FullOpts,{LineColor->Automatic,LineOpacity->Automatic}]]
];

MakeRawGraphics[Art_,Opts___?OptionQ] := Module[
{
FullOpts=Flatten[{Opts}]
},

CheckOption[Show,True|False,FullOpts];
CheckOption[Layer,Automatic|_?NumericQ,FullOpts];

If[Show/.FullOpts,
SchemeGraphics[
MakeRawGraphicsDirectives[FullOpts],
Art,
GetAutoOption[Layer,$SchemeDrawingLayer,FullOpts]
]
]
];


MakeRawGraphics3D[Art_,Opts___?OptionQ] := Module[
{
FullOpts=Flatten[{Opts}]
},

CheckOption[Show,True|False,FullOpts];

If[
Show/.FullOpts,
Graphics3D[Flatten[{
MakeRawGraphicsDirectives[FullOpts],
Art
}]]
]
];


MakeVerbatim[Art_,Opts___?OptionQ] := Module[
{
FullOpts=Flatten[{Opts}]
},

CheckOption[Show,True|False,FullOpts];
CheckOption[Layer,Automatic|_?NumericQ,FullOpts];

If[Show/.FullOpts,
SchemeGraphics[
{},
Art,
GetAutoOption[Layer,$SchemeDrawingLayer,FullOpts]
]
]
];


BasicLineAnnotations[Points_List,FullOpts_List]:=Module[
{AbsPoints,Lengths,LengthSoFar,CurveParam,
AbsXFcn,AbsYFcn,AbsPFcn,AbsTangentFcn,
HalfWidthForLabels,
bufft,offt,OptPosnT,PointT,AngleT,
buffb,offb,OptPosnB,PointB,AngleB,
OptPosnL,PointL,AngleL,
OptPosnR,PointR,AngleR,
OptPosnC,PointC,AngleC},

(* option processing *)
CheckOption[PosnL,Automatic|(_?NumericQ),FullOpts];
CheckOption[PosnR,Automatic|(_?NumericQ),FullOpts];
CheckOption[PosnT,Automatic|(_?NumericQ),FullOpts];
CheckOption[PosnB,Automatic|(_?NumericQ),FullOpts];
CheckOption[PosnC,Automatic|(_?NumericQ),FullOpts];

(* parametrize data curve *)
AbsPoints=PAOfPC/@Points;
Lengths=VectorLength/@(Drop[AbsPoints,-1]-Drop[AbsPoints,1]);  (* i.e., Most-Rest *)
LengthSoFar=0.;
CurveParam=(LengthSoFar+=#&)/@Prepend[Lengths,0.]/LengthSoFar;
AbsXFcn=Interpolation[Transpose[{CurveParam,First/@AbsPoints}],InterpolationOrder->1];
AbsYFcn=Interpolation[Transpose[{CurveParam,Last/@AbsPoints}],InterpolationOrder->1];
AbsPFcn=({AbsXFcn[#],AbsYFcn[#]}&);
AbsTangentFcn=(
{Derivative[1][AbsXFcn][#],Derivative[1][AbsYFcn][#]}/VectorLength[{Derivative[1][AbsXFcn][#],Derivative[1][AbsYFcn][#]}]
&);  
AbsNormalFcn=({{0,-1},{1,0}}.AbsTangentFcn[#]&);

HalfWidthForLabels=0;

SuppressMessage[
(* silently allow linear extrapolation of curve *)
InterpolatingFunction::"dmval",
{

If[
((LabT/.FullOpts)=!=None)&&(ShowLabT/.FullOpts),
offt=GetAutoOption[OffsetT,
Switch[(OrientationT/.FullOpts),
Horizontal|Vertical,{0,-1},
Automatic|Inverted|_,{0,0}
],
FullOpts
];
bufft=GetAutoOption[BufferT,
Switch[(OrientationT/.FullOpts),
Horizontal|Vertical,0,
Automatic|Inverted|_,1.1
],
FullOpts
];
OptPosnT=GetAutoOption[PosnT,0.5,FullOpts];
PointT=PCOfPA@(AbsPFcn[OptPosnT]+AbsNormalFcn[OptPosnT]*(HalfWidthForLabels+bufft/2*(FontSize/.FullOpts)));
AngleT=VectorArcTan[AbsTangentFcn[OptPosnT]];
MakeText[(LabT/.FullOpts),PointT,AngleT,
ShowText->(ShowLabT/.FullOpts),
Offset->offt,
Nudge->(NudgeT/.FullOpts),
Orientation->(OrientationT/.FullOpts),
Background->(BackgroundT/.FullOpts),
FullOpts 
]
],

If[
((LabB/.FullOpts)=!=None)&&(ShowLabB/.FullOpts),
offb=GetAutoOption[OffsetB,
Switch[(OrientationB/.FullOpts),
Horizontal|Vertical,{0,+1},
Automatic|Inverted|_,{0,0}
],
FullOpts
];
buffb=GetAutoOption[BufferB,
Switch[(OrientationB/.FullOpts),
Horizontal|Vertical,0,
Automatic|Inverted|_,1.1
],
FullOpts
];
OptPosnB=GetAutoOption[PosnB,0.5,FullOpts];
PointB=PCOfPA@(AbsPFcn[OptPosnB]-AbsNormalFcn[OptPosnB]*(HalfWidthForLabels+buffb/2*(FontSize/.FullOpts)));
AngleB=VectorArcTan[AbsTangentFcn[OptPosnB]];
MakeText[(LabB/.FullOpts),PointB,AngleB,
ShowText->(ShowLabB/.FullOpts),
Offset->offb,
Nudge->(NudgeB/.FullOpts),
Orientation->(OrientationB/.FullOpts),
Background->(BackgroundB/.FullOpts),
FullOpts 
]
],

If[
((LabL/.FullOpts)=!=None)&&(ShowLabL/.FullOpts),
OptPosnL=GetAutoOption[PosnL,0.0,FullOpts];
PointL=PCOfPA@AbsPFcn[OptPosnL];
AngleL=VectorArcTan[AbsTangentFcn[OptPosnL]];
MakeText[(LabL/.FullOpts),PointL,AngleL,
ShowText->(ShowLabL/.FullOpts),
Offset->GetAutoOption[OffsetL,{+1,0},FullOpts],
Nudge->(NudgeL/.FullOpts),
Orientation->(OrientationL/.FullOpts),
Background->(BackgroundL/.FullOpts),
FullOpts 
]
],

If[
((LabR/.FullOpts)=!=None)&&(ShowLabR/.FullOpts),
OptPosnR=GetAutoOption[PosnR,1.0,FullOpts];
PointR=PCOfPA@AbsPFcn[OptPosnR];
AngleR=VectorArcTan[AbsTangentFcn[OptPosnR]];
MakeText[(LabR/.FullOpts),PointR,AngleR,
ShowText->(ShowLabR/.FullOpts),
Offset->GetAutoOption[OffsetR,{-1,0},FullOpts],
Nudge->(NudgeR/.FullOpts),
Orientation->(OrientationR/.FullOpts),
Background->(BackgroundR/.FullOpts),
FullOpts 
]
],


If[
((LabC/.FullOpts)=!=None)&&(ShowLabC/.FullOpts),
OptPosnC=GetAutoOption[PosnC,0.5,FullOpts];
PointC=PCOfPA@AbsPFcn[OptPosnC];
AngleC=VectorArcTan[AbsTangentFcn[OptPosnC]];
MakeText[(LabC/.FullOpts),PointC,AngleC,
ShowText->(ShowLabC/.FullOpts),
Offset->GetAutoOption[OffsetC,{0,0},FullOpts],
Nudge->(NudgeC/.FullOpts),
Orientation->(OrientationC/.FullOpts),
Background->(BackgroundC/.FullOpts),
FullOpts 
]
]
}
]

];


ArrowPoint[Caller_Symbol,{Pia_List,Pfa_List},AtUserPosition,x_,ya_]:=Module[
{theta,d,xa},
CheckValue[
x,
(_?NumericQ)|FromHead[_?NumericQ]|FromTail[_?NumericQ]|FromHeadVertical[_?NumericQ]|FromTailVertical[_?NumericQ]|FromHeadHorizontal[_?NumericQ]|FromTailHorizontal[_?NumericQ],
"a label position"
];
theta=VectorArcTan[Pfa-Pia];
d=VectorLength[Pfa-Pia];
xa=Switch[x,
_?NumericQ,x*d,
FromHead[_?NumericQ],d-x[[1]],
FromTail[_?NumericQ],x[[1]],
FromHeadVertical[_?NumericQ],If[Chop[Sin[theta]]==0,ErrorMessage[Caller::fromvert]];(d-x[[1]])*(-Csc[theta]),
FromTailVertical[_?NumericQ],If[Chop[Sin[theta]]==0,ErrorMessage[Caller::fromvert]];(x[[1]])*(-Csc[theta]),
FromHeadHorizontal[_?NumericQ],If[Chop[Cos[theta]]==0,ErrorMessage[Caller::fromhoriz]];(d-x[[1]])*(-Sec[theta]),
FromTailHorizontal[_?NumericQ],If[Chop[Cos[theta]]==0,ErrorMessage[Caller::fromhoriz]];(x[[1]])*(-Sec[theta])
];
Pia+LegacyRotate2D[{xa,ya},-theta]
];
ArrowPoint[{Pia_List,Pfa_List},AtPosition,xa_,ya_]:=Module[
{theta,d},
theta=VectorArcTan[Pfa-Pia];
d=VectorLength[Pfa-Pia];
Pia+LegacyRotate2D[{xa,ya},-theta]
];
ArrowPoint[{Pia_List,Pfa_List},AtTail,ya_]:=Module[
{theta,d},
theta=VectorArcTan[Pfa-Pia];
d=VectorLength[Pfa-Pia];
Pia+LegacyRotate2D[{0,ya},-theta]
];
ArrowPoint[{Pia_List,Pfa_List},AtTailHorizontal,ya_]:=Module[
{theta},
theta=VectorArcTan[Pfa-Pia];
Pia+{-ya*Csc[theta],0} 
];
ArrowPoint[{Pia_List,Pfa_List},AtHead,ya_]:=Module[
{theta,d},
theta=VectorArcTan[Pfa-Pia];
d=VectorLength[Pfa-Pia];
Pia+LegacyRotate2D[{d,ya},-theta]
];
ArrowPoint[{Pia_List,Pfa_List},AtHeadHorizontal,ya_]:=Module[
{theta},
theta=VectorArcTan[Pfa-Pia];
Pfa+{-ya*Csc[theta],0}
];
ArrowPoint[{Pia_List,Pfa_List},AtLip,HeadLength_,ya_]:=Module[
{theta,d},
theta=VectorArcTan[Pfa-Pia];
d=VectorLength[Pfa-Pia];
Pia+LegacyRotate2D[{d-HeadLength,ya},-theta]
];
ArrowPoint[{Pia_List,Pfa_List},AtTailLip,HeadLength_,ya_]:=Module[
{theta,d},
theta=VectorArcTan[Pfa-Pia];
d=VectorLength[Pfa-Pia];
Pia+LegacyRotate2D[{HeadLength,ya},-theta]
];
ArrowPoint[{Pia_List,Pfa_List},AtEdge,HeadLength_,HeadHalfWidth_,ya_]:=Module[
{theta,d},
theta=VectorArcTan[Pfa-Pia];
d=VectorLength[Pfa-Pia];
Pia+LegacyRotate2D[{d-Abs[ya]*HeadLength/HeadHalfWidth,ya},-theta]
];


SquigglePoints[{Pia_List,Pfa_List},{MinBuffer1_,MinBuffer2_},HalfWidth_,SquiggleWavelength_,SquiggleSide_,PlotPoints_]:=Module[
{theta,d,dp,Delta,x,PointList,s},
s=Switch[SquiggleSide,Right,+1,Left,-1];
theta=VectorArcTan[Pfa-Pia];
d=VectorLength[Pfa-Pia];
dp=(SquiggleWavelength/2)*Floor[Max[(d-MinBuffer1-MinBuffer2),0]/(SquiggleWavelength/2)];
Delta=(d-MinBuffer1-MinBuffer2-dp)/2;
PointList=Table[
Pia+LegacyRotate2D[{x+MinBuffer1+Delta,s*HalfWidth*Sin[2*Pi/SquiggleWavelength*x]},-theta],
{x,0,dp,SquiggleWavelength/PlotPoints}
];
Join[{Pia},PointList,{Pfa}]
];


ArrowHeadPoints[{P1a:{_?NumericQ,_?NumericQ},P2a:{_?NumericQ,_?NumericQ}},HeadLength_?NumericQ,HeadLip_?NumericQ] := ArrowHeadPoints[P2a,VectorArcTan[P2a-P1a],HeadLength,HeadLip];
ArrowHeadPoints[Pa:{_?NumericQ,_?NumericQ},theta_?NumericQ,HeadLength_?NumericQ,HeadLip_?NumericQ] := Module[
{},
{
Pa+LegacyRotate2D[{-HeadLength,+HeadLip},-theta],
Pa+{0.,0.},
Pa+LegacyRotate2D[{-HeadLength,-HeadLip},-theta]
}
];


BasicArrow[Caller_Symbol,Nodes_List,FullOpts_List] := Module[
{
PointList,
AbsNodes,AbsSegments,Segment,
ConversionPointList,ConversionP0,ConversionP4,ConversionWidth,Conversiony,ConversionSideSign,
d,dp,dk,Delta,
ShaftPosition,ShaftPoints,
LineArt,TextArt,

HalfWidthForLabels,
PLa,PRa,PCa,PTa,
offl,offr,offc,offkc,offt,
buffl,buffr,
SegmentPointsL,SegmentPointsC,SegmentPointsR,SegmentPointsT,

OptWidth,
OptThickness,
OptHeadLength,
OptShaftLines,
OptHeadLip
},

(* option checks *)
CheckOption[ArrowType,LineArrow|MultilineArrow|SquiggleArrow|ShapeArrow,FullOpts];
CheckOption[ArrowHalf,All|Left|Right,FullOpts];
CheckOption[HeadLength,_?NumericQ,FullOpts];
CheckOption[HeadLip,_?NumericQ,FullOpts];
CheckOption[Width,_?NumericQ,FullOpts];
CheckOption[TailBevel,True|False,FullOpts];
CheckOption[ShaftLines,(x_Integer)/;(x>=2),FullOpts];
CheckOption[PlotPoints,(x_Integer)/;(x>=4),FullOpts];
CheckOption[SquiggleBuffer,(x_?NumericQ)/;(x>=0),FullOpts];
CheckOption[SquiggleWavelength,(x_?NumericQ)/;(x>0),FullOpts];
CheckOption[SquiggleSide,Left|Right,FullOpts];
CheckOption[SegmentL,Automatic|(x_Integer/;((x!=0)&&(Abs[x]<Length[Nodes]))),FullOpts];
CheckOption[SegmentR,Automatic|(x_Integer/;((x!=0)&&(Abs[x]<Length[Nodes]))),FullOpts];
CheckOption[SegmentC,Automatic|(x_Integer/;((x!=0)&&(Abs[x]<Length[Nodes]))),FullOpts];
If[
(!MatchQ[ArrowType/.FullOpts,LineArrow])&&(Length[Nodes]>2),
ErrorMessage[Caller::kinks]
];
CheckOption[ShowHead,True|False,FullOpts];
CheckOption[ShowTail,True|False,FullOpts];
If[
!MatchQ[ArrowType/.FullOpts,LineArrow|SquiggleArrow],
CheckOption[ShowTail,False,FullOpts]
];
CheckOption[ConversionSide,Left|Right,FullOpts];
CheckOption[ConversionCoeff,None|_?NumericQ|Infinity,FullOpts];
If[((ConversionCoeff/.FullOpts)=!=None)&&((HeadLip/.FullOpts)=!=0),Message[Caller::conversionlip]];
If[(AboveKinkL/.FullOpts)=!=False,Message[LevelScheme::abovekinkx]];
If[(AboveKinkR/.FullOpts)=!=False,Message[LevelScheme::abovekinkx]];
If[(AboveKinkC/.FullOpts)=!=False,Message[LevelScheme::abovekinkx]];

(* calculate arrow geometry -- absolute coordinates *)
AbsNodes=PAOfPC/@Nodes;
AbsSegments=Partition[AbsNodes,2,1];
If[MemberQ[Chop/@SegmentLength/@AbsSegments,0],ErrorMessage[Caller::nullsegment,Nodes]];
Segment=AbsSegments[[-1]];  (* shorthand useful for single-segment arrow types *)
OptWidth=(Width/.FullOpts);
OptHeadLength=(HeadLength/.FullOpts);
OptHeadLip=(HeadLip/.FullOpts);
OptShaftLines = (ShaftLines/.FullOpts);
OptThickness=(Thickness/.FullOpts);

(* make arrow *)
LineArt=Switch[
(ArrowType/.FullOpts),
LineArrow,
{

(* shaft *)
MakeOutline[{Line[PCOfPA/@AbsNodes]},FullOpts] ,

(* head *)
If[ShowHead/.FullOpts,
MakeOutline[{Line[PCOfPA/@ArrowHeadPoints[AbsSegments[[-1]],OptHeadLength,OptHeadLip]]},Dashing->None,FullOpts]
],

(* tail *)
If[ShowTail/.FullOpts,
MakeOutline[{Line[PCOfPA/@ArrowHeadPoints[Reverse@AbsSegments[[1]],OptHeadLength,OptHeadLip]]},Dashing->None,FullOpts]
]

},
MultilineArrow,
{

ShaftPoints=Table[
ShaftPosition=OptWidth*(-1/2+i/(OptShaftLines-1));
Switch[
(TailBevel/.FullOpts),
False,
{ArrowPoint[Segment,AtTail,ShaftPosition],ArrowPoint[Segment,AtEdge,OptHeadLength,OptWidth/2+OptHeadLip,ShaftPosition]},
True,
{ArrowPoint[Segment,AtTailHorizontal,ShaftPosition],ArrowPoint[Segment,AtEdge,OptHeadLength,OptWidth/2+OptHeadLip,ShaftPosition]}
],
{i,0,OptShaftLines-1}
];

(* fill *)
MakeFill[
{
Polygon[PCOfPA/@Join[First[ShaftPoints],{Last[Segment]},Reverse[Last[ShaftPoints]]]]
},
FullOpts],

(* shaft lines *)
MakeOutline[
{
Table[
Line[PCOfPA/@ShaftPoints[[i]]],
{i,1,OptShaftLines}
]
},
FullOpts] ,

(* head *)
If[ShowHead/.FullOpts,
MakeOutline[{Line[PCOfPA/@ArrowHeadPoints[Segment,OptHeadLength,OptWidth/2+OptHeadLip]]},Dashing->None,FullOpts]
]
},
SquiggleArrow,
{
(* main segment *)
PointList=SquigglePoints[
Segment,
{
If[(ShowTail/.FullOpts),OptHeadLength,0]+(SquiggleBuffer/.FullOpts),
If[(ShowHead/.FullOpts),OptHeadLength,0]+(SquiggleBuffer/.FullOpts)
},
OptWidth/2,
(SquiggleWavelength/.FullOpts),
(SquiggleSide/.FullOpts),
(PlotPoints/.FullOpts)
];
MakeOutline[{Line[PCOfPA/@PointList]},FullOpts] ,

(* head *)
If[ShowHead/.FullOpts,
MakeOutline[{Line[PCOfPA/@ArrowHeadPoints[Segment,OptHeadLength,OptHeadLip]]},Dashing->None,FullOpts]
],

(* tail *)
If[ShowTail/.FullOpts,
MakeOutline[{Line[PCOfPA/@ArrowHeadPoints[Reverse@Segment,OptHeadLength,OptHeadLip]]},Dashing->None,FullOpts]
]

},
ShapeArrow,
{

PointList=Switch[
(TailBevel/.FullOpts),
False,
 {
First[Segment],
ArrowPoint[Segment,AtTail,-(OptWidth/2)],
ArrowPoint[Segment,AtLip,OptHeadLength,-(OptWidth/2)],ArrowPoint[Segment,AtLip,OptHeadLength,-(OptWidth/2+OptHeadLip)],
Last[Segment],
ArrowPoint[Segment,AtLip,OptHeadLength,+(OptWidth/2+OptHeadLip)],
ArrowPoint[Segment,AtLip,OptHeadLength,+(OptWidth/2)],
ArrowPoint[Segment,AtTail,+(OptWidth/2)]
},
True,
{
First[Segment],
ArrowPoint[Segment,AtTailHorizontal,-(OptWidth/2)],
ArrowPoint[Segment,AtLip,OptHeadLength,-(OptWidth/2)],
ArrowPoint[Segment,AtLip,OptHeadLength,-(OptWidth/2+OptHeadLip)],
Last[Segment],
ArrowPoint[Segment,AtLip,OptHeadLength,+(OptWidth/2+OptHeadLip)],
ArrowPoint[Segment,AtLip,OptHeadLength,+(OptWidth/2)],
ArrowPoint[Segment,AtTailHorizontal,+(OptWidth/2)]
}
];
PointList=Switch[
(ArrowHalf/.FullOpts),
All,PointList,
Left,Take[PointList,5],
Right,Take[RotateLeft[PointList],-5]
];
If[
(ConversionCoeff/.FullOpts)=!=None,
ConversionSideSign=Switch[(ConversionSide/.FullOpts),Left,+1,Right,-1];
ConversionWidth=If[
(ConversionCoeff/.FullOpts)==Infinity,
Width/.FullOpts,
(Width*ConversionCoeff/(1+ConversionCoeff))/.FullOpts
];
Conversiony=ConversionSideSign*((ConversionWidth-Width/2)/.FullOpts);
ConversionP0=Switch[
(TailBevel/.FullOpts),
False,
ArrowPoint[Segment,AtTail,Conversiony],
True,
ArrowPoint[Segment,AtTailHorizontal,Conversiony]
];
ConversionP4=ArrowPoint[Segment,AtEdge,OptHeadLength,(OptWidth/2+OptHeadLip),Conversiony];
ConversionPointList=Switch[
(ConversionSide/.FullOpts),
Left,
Join[
PointList[[{1,2,3}]],
If[Conversiony>0,PointList[[{4}]],{}],
{ConversionP4,ConversionP0}
],
Right,
Join[
PointList[[{7,6,5}]],
If[Conversiony<0,PointList[[{4}]],{}],
{ConversionP4,ConversionP0}
]
]
];

MakeFill[
{
Polygon[PCOfPA/@PointList]
},
FullOpts],
If[(ConversionCoeff/.FullOpts)=!=None,
MakeFill[
{
Polygon[PCOfPA/@ConversionPointList]
},
FillColor->(ConversionColor/.FullOpts),FullOpts]
],
MakeOutline[
{
Line[PCOfPA/@(PointList~Append~First[PointList])]
},
FullOpts]
}

];

(* make labels *)

HalfWidthForLabels=Switch[(ArrowType/.FullOpts),
LineArrow,OptThickness/2,
MultilineArrow|SquiggleArrow|ShapeArrow,(OptWidth+OptThickness)/2
];

TextArt={
If[
((LabL/.FullOpts)=!=None)&&(ShowLabL/.FullOpts),
offl=GetAutoOption[OffsetL,
Switch[(OrientationL/.FullOpts),
Automatic,{0,0},
Inverted,{0,0},
Horizontal,{1,0},
Vertical,{1,0},
_, {0,0}
],
FullOpts
];
buffl=GetAutoOption[BufferL,
Switch[(OrientationL/.FullOpts),
Automatic,1.1,
Inverted,1.1,
Horizontal,0,
Vertical,0,
_, 1.1
],
FullOpts
];
SegmentPointsL=Switch[
(SegmentL/.FullOpts),
Automatic,AbsSegments[[-1]],
_Integer,AbsSegments[[(SegmentL/.FullOpts)]]
];
PLa=ArrowPoint[Caller,SegmentPointsL,AtUserPosition,GetAutoOption[PosnL,0.5,FullOpts],-(HalfWidthForLabels+buffl/2*(FontSize/.FullOpts))];
MakeText[(LabL/.FullOpts),PCOfPA[PLa],SegmentArcTan[SegmentPointsL],
ShowText->(ShowLabL/.FullOpts),
Offset->offl,
Nudge->(NudgeL/.FullOpts),
Orientation->(OrientationL/.FullOpts),
Background->(BackgroundL/.FullOpts),
FullOpts 
]
],

If[
((LabR/.FullOpts)=!=None)&&(ShowLabR/.FullOpts),
offr=GetAutoOption[OffsetR,
Switch[(OrientationR/.FullOpts),
Automatic,{0,0},
Inverted,{0,0},
Horizontal,{-1,0},
Vertical,{0,0},
_, {0,0}
],
FullOpts
];
buffr=GetAutoOption[BufferR,
Switch[(OrientationR/.FullOpts),
Automatic,1.1,
Inverted,1.1,
Horizontal,0,
Vertical,0,
_, 1.1
],
FullOpts
];
SegmentPointsR=Switch[
(SegmentR/.FullOpts),
Automatic,AbsSegments[[-1]],
_Integer,AbsSegments[[(SegmentR/.FullOpts)]]
];
PRa=ArrowPoint[Caller,SegmentPointsR,AtUserPosition,GetAutoOption[PosnR,0.5,FullOpts],+(HalfWidthForLabels+buffr/2*(FontSize/.FullOpts))];
MakeText[(LabR/.FullOpts), PCOfPA[PRa],SegmentArcTan[SegmentPointsR],
ShowText->(ShowLabR/.FullOpts),
Offset->offr,
Nudge->(NudgeR/.FullOpts),
Orientation->(OrientationR/.FullOpts),
Background->(BackgroundR/.FullOpts),
FullOpts 
]
],

If[
((LabC/.FullOpts)=!=None)&&(ShowLabC/.FullOpts),
offc=GetAutoOption[OffsetC,
{0,0},
FullOpts
];
SegmentPointsC=Switch[
(SegmentC/.FullOpts),
Automatic,AbsSegments[[-1]],
_Integer,AbsSegments[[(SegmentC/.FullOpts)]]
];
PCa=ArrowPoint[Caller,SegmentPointsC,AtUserPosition,GetAutoOption[PosnC,0.5,FullOpts],0];
MakeText[(LabC/.FullOpts), PCOfPA[PCa],SegmentArcTan[SegmentPointsC],
ShowText->(ShowLabC/.FullOpts),
Offset->offc,
Nudge->(NudgeC/.FullOpts),
Orientation->(OrientationC/.FullOpts),
Background->(BackgroundC/.FullOpts),
FullOpts 
]
],

If[
((LabT/.FullOpts)=!=None)&&(ShowLabT/.FullOpts),
offt=GetAutoOption[OffsetT,
Switch[(OrientationT/.FullOpts),
Automatic,{0,-1},
Inverted,{0,-1},
Horizontal,{0,-1},
Vertical,{0,-1},
_, {0,0}
],
FullOpts
];
SegmentPointsT=AbsSegments[[1]];
PTa=ArrowPoint[Caller,SegmentPointsT,AtUserPosition,GetAutoOption[PosnT,0,FullOpts],0];
MakeText[(LabT/.FullOpts), PCOfPA[PTa],SegmentArcTan[SegmentPointsT],
ShowText->(ShowLabT/.FullOpts),
Offset->offt,
Nudge->(NudgeT/.FullOpts),
Orientation->(OrientationT/.FullOpts),
Background->(BackgroundT/.FullOpts),
FullOpts 
]
]

};

(* return completed artwork *)
Join[LineArt,TextArt]

];


Lev[ID_:Dummy,xa0_?NumericQ,xb0_?NumericQ,EnergyStr:(_?NumericQ|_String),Opts___?OptionQ] := Module[
{
FullOpts=RealizeOptions[Lev,Opts],
WingRiseWidthL,WingRiseWidthR,
WingTipWidthL,WingTipWidthR,
PointList,
IDExpr
},

CheckInScheme[];
CheckValue[ID,IDExpr_?LevelIdentifierQ,"a level identifier symbol (cannot be list or number)"];
CheckOption[EnergyNudge,_?NumericQ,FullOpts];
CheckOption[WingHeight,_?NumericQ,FullOpts];
CheckOption[WingRiseWidth,(_?NumericQ)|{_?NumericQ,_?NumericQ},FullOpts];
CheckOption[WingTipWidth,(_?NumericQ)|{_?NumericQ,_?NumericQ},FullOpts];
CheckOption[MakeWingL,True|False,FullOpts];
CheckOption[MakeWingR,True|False,FullOpts];

(* label validation *)
CheckOption[ShowLabL,True|False,FullOpts];
CheckOption[ShowLabR,True|False,FullOpts];
CheckOption[ShowLabT,True|False,FullOpts];
CheckOption[ShowLabB,True|False,FullOpts];
CheckOption[ShowLabC,True|False,FullOpts];

(* Store level parameters *)
$LastLevel=ID;
LevelScheme`Data`xa0[ID]=XCOfXU[xa0];
LevelScheme`Data`xb0[ID]=XCOfXU[xb0];
LevelScheme`Data`xa[ID]= XCOfXU[xa0+(Margin/.FullOpts)];
LevelScheme`Data`xb[ID]= XCOfXU[xb0-(Margin/.FullOpts)];
LevelScheme`Data`UserEnergy[ID]=Switch[EnergyStr,
_?NumericQ,EnergyStr,
_String,ToExpression[EnergyStr]
];
If[
!NumericQ[LevelScheme`Data`UserEnergy[ID]],
ErrorMessage[Lev::energystr,If[ID===Dummy,"no ID given",ID],EnergyStr]
];
LevelScheme`Data`Energy[ID] = YCOfYU[LevelScheme`Data`UserEnergy[ID]]+DYCOfYA[EnergyNudge/.FullOpts];
LevelScheme`Data`WingEnergy[ID] =LevelScheme`Data`Energy[ID]+DYCOfYA[WingHeight/.FullOpts];

{

(* Outline *)

{WingRiseWidthL,WingRiseWidthR}=UpgradeScalarXY[WingRiseWidth/.FullOpts];{WingTipWidthL,WingTipWidthR}=UpgradeScalarXY[WingTipWidth/.FullOpts];PointList=Join[
If[
(MakeWingL/.FullOpts)&&(WingHeight/.FullOpts)=!=0,
LevelScheme`Data`EnergyL[ID]=LevelScheme`Data`WingEnergy[ID];
{
{LevelScheme`Data`xa[ID] ,LevelScheme`Data`WingEnergy[ID]},
{LevelScheme`Data`xa[ID]+DXCOfXA[WingTipWidthL] ,LevelScheme`Data`WingEnergy[ID]},
{LevelScheme`Data`xa[ID]+DXCOfXA[WingTipWidthL] +DXCOfXA[WingRiseWidthL] ,LevelScheme`Data`Energy[ID]}
},
LevelScheme`Data`EnergyL[ID]=LevelScheme`Data`Energy[ID];
{
{LevelScheme`Data`xa[ID] ,LevelScheme`Data`Energy[ID]}
}
],
If[
(MakeWingR/.FullOpts)&&(WingHeight/.FullOpts)=!=0,
LevelScheme`Data`EnergyR[ID]=LevelScheme`Data`WingEnergy[ID];
{
{LevelScheme`Data`xb[ID]-DXCOfXA[WingTipWidthR] -DXCOfXA[WingRiseWidthR] ,LevelScheme`Data`Energy[ID]},
{LevelScheme`Data`xb[ID]-DXCOfXA[WingTipWidthR] ,LevelScheme`Data`WingEnergy[ID]},
{LevelScheme`Data`xb[ID],LevelScheme`Data`WingEnergy[ID]}
},
LevelScheme`Data`EnergyR[ID]=LevelScheme`Data`Energy[ID];
{
{LevelScheme`Data`xb[ID] ,LevelScheme`Data`Energy[ID]}
}
]
];

MakeOutline[
{
Line[PointList]
},
If[(LineToFront/.FullOpts),Layer->$SchemeTextLayer,{}],
FullOpts
],

(* Labels *)
DefaultLabel=Switch[
EnergyStr,
_String,EnergyStr,
_?NumericQ,(EnergyLabelFunction/.FullOpts)@EnergyStr
];
MakeText[
GetAutoOption[LabL,DefaultLabel,FullOpts],
{LevelScheme`Data`xa[ID],LevelScheme`Data`EnergyL[ID]},
0,
ShowText->(ShowLabL/.FullOpts),
Offset->GetAutoOption[OffsetL,{-1,-.75},FullOpts],
Nudge->(NudgeL/.FullOpts),
Orientation->GetAutoOption[OrientationL,Horizontal,FullOpts],
Background->(BackgroundL/.FullOpts),
FullOpts 
],

MakeText[
GetAutoOption[LabC,DefaultLabel,FullOpts],
{(LevelScheme`Data`xa[ID]+LevelScheme`Data`xb[ID])/2,LevelScheme`Data`Energy[ID]},
0,
ShowText->(ShowLabC/.FullOpts),
Offset->GetAutoOption[OffsetC,{0,-.75},FullOpts],
Nudge->(NudgeC/.FullOpts),
Orientation->GetAutoOption[OrientationC,Horizontal,FullOpts],
Background->(BackgroundC/.FullOpts),
FullOpts 
],

MakeText[
GetAutoOption[LabR,DefaultLabel,FullOpts],
{LevelScheme`Data`xb[ID],LevelScheme`Data`EnergyR[ID]},
0,
ShowText->(ShowLabR/.FullOpts),
Offset->GetAutoOption[OffsetR,{+1,-.75},FullOpts],
Nudge->(NudgeR/.FullOpts),
Orientation->GetAutoOption[OrientationR,Horizontal,FullOpts],
Background->(BackgroundR/.FullOpts),
FullOpts 
],

MakeText[
GetAutoOption[LabT,DefaultLabel,FullOpts],
{(LevelScheme`Data`xa[ID]+LevelScheme`Data`xb[ID])/2,LevelScheme`Data`Energy[ID]},
0,
ShowText->(ShowLabT/.FullOpts),
Offset->GetAutoOption[OffsetT,{0,-.75},FullOpts],
Nudge->(NudgeT/.FullOpts),
Orientation->GetAutoOption[OrientationT,Horizontal,FullOpts],
Background->(BackgroundT/.FullOpts),
FullOpts 
],

MakeText[
GetAutoOption[LabB,DefaultLabel,FullOpts],
{(LevelScheme`Data`xa[ID]+LevelScheme`Data`xb[ID])/2,LevelScheme`Data`Energy[ID]},
0,
ShowText->(ShowLabB/.FullOpts),
Offset->GetAutoOption[OffsetC,{0,+.75},FullOpts],
Nudge->(NudgeB/.FullOpts),
Orientation->GetAutoOption[OrientationB,Horizontal,FullOpts],
Background->(BackgroundB/.FullOpts),
FullOpts 
]

}
];


LastLevel:=Module[
{},
CheckInScheme[];
$LastLevel
];
LevelEnergy[ID_?LevelIdentifierQ] :=Module[
{},
CheckInScheme[];
CheckLevel[ID];
LevelScheme`Data`UserEnergy[ID]
];


BasicExtensionLine[ID_?LevelIdentifierQ,x1_,x2_,FullOpts_List] := Module[
{},
CheckInScheme[];
CheckLevel[ID];

{
MakeOutline[
{
If[
(ToWing/.FullOpts),
Line[{{x1,LevelScheme`Data`WingEnergy[ID]},{x2,LevelScheme`Data`WingEnergy[ID]}}],
Line[{{x1,LevelScheme`Data`Energy[ID]},{x2,LevelScheme`Data`Energy[ID]}}]
]
},
FullOpts
]
}
];
ExtensionLine[ID_?LevelIdentifierQ,Posn1_?NumericQ,Posn2_?NumericQ,Opts___?OptionQ] :=BasicExtensionLine[ID,LevelScheme`Data`xa0[ID] +DXCOfXU[Posn1],LevelScheme`Data`xa0[ID] +DXCOfXU[Posn2],RealizeOptions[ExtensionLine,Opts]];
ExtensionLine[ID_?LevelIdentifierQ,Left,Length_,Opts___?OptionQ] := BasicExtensionLine[ID,LevelScheme`Data`xa[ID]-DXCOfXU[Length],LevelScheme`Data`xa[ID],RealizeOptions[ExtensionLine,Opts]];
ExtensionLine[ID_?LevelIdentifierQ,Right,Length_,Opts___?OptionQ] := BasicExtensionLine[ID,LevelScheme`Data`xb[ID],LevelScheme`Data`xb[ID]+DXCOfXU[Length],RealizeOptions[ExtensionLine,Opts]];


Connector[IDi_?LevelIdentifierQ,IDf_?LevelIdentifierQ,Opts___?OptionQ] :=Module[
{
FullOpts=RealizeOptions[Connector,Opts]
},

CheckInScheme[];
CheckLevel[IDi];
CheckLevel[IDf];

MakeOutline[
{
Line[{{LevelScheme`Data`xb[IDi],LevelScheme`Data`EnergyR[IDi]},{LevelScheme`Data`xa[IDf],LevelScheme`Data`EnergyL[IDf]}}]
},
FullOpts
]
];


ArrowNodeQ[P_]:=MatchQ[P,{_?NumericQ,_?NumericQ}|FromHead[_?DoubleRadiusQ]|FromTail[_?DoubleRadiusQ]];


Trans[RawNodes:{PI:{_?NumericQ,_?NumericQ},(_?ArrowNodeQ)...,Pf:{_?NumericQ,_?NumericQ}},Opts___?OptionQ] := Module[
{
FullOpts=RealizeOptions[Trans,Opts],
Nodes,R,P
},

CheckInScheme[];
CheckOption[Kink,FullOpts];

Nodes=Replace[
RawNodes,
{
P:{_?NumericQ,_?NumericQ}:>PCOfPU@P,
FromHead[R_]:>(PCOfPU@Pf+ConvertRadiusToCanvas[R]),
FromTail[R_]:>(PCOfPU@PI+ConvertRadiusToCanvas[R])
},
1
];

BasicArrow[Trans,Nodes,FullOpts]
];
Trans[PI:{_?NumericQ,_?NumericQ},Pf:{_?NumericQ,_?NumericQ},Opts___?OptionQ] := Module[
{
FullOpts=RealizeOptions[Trans,Opts],
RawNodes,Nodes,R,P
},

CheckInScheme[];
CheckOption[Kink,None|_?ArrowNodeQ|{(_?ArrowNodeQ)...},FullOpts];

RawNodes=Join[
{PI},
Switch[
(Kink/.FullOpts),
None,{},
_?ArrowNodeQ,{(Kink/.FullOpts)},
{(_?ArrowNodeQ)...},(Kink/.FullOpts)
],
{Pf}
];
Nodes=Replace[
RawNodes,
{
P:{_?NumericQ,_?NumericQ}:>PCOfPU@P,
FromHead[R_]:>(PCOfPU@Pf+ConvertRadiusToCanvas[R]),
FromTail[R_]:>(PCOfPU@PI+ConvertRadiusToCanvas[R])
},
1
];

BasicArrow[Trans,Nodes,FullOpts]
];
Trans[IDi_?LevelIdentifierQ,IDf_?LevelIdentifierQ,Opts___?OptionQ] := Module[
{
FullOpts=RealizeOptions[Trans,Opts],
xi,yi,xf,yf,
PI,Pf,
Posni,Posnf
},

CheckInScheme[];
CheckOption[EndPositions,{(_?NumericQ|Automatic),(_?NumericQ|Automatic)},FullOpts];
CheckLevel[IDi];
CheckLevel[IDf];
{Posni,Posnf}=(EndPositions/.FullOpts);

(* Calculate start, end, and optional kink points *)
(* PI and Pf are distance in band units from left origin of band *)
{xi,xf}=Which[
(Posni=!=Automatic)&&(Posnf=!=Automatic),
{LevelScheme`Data`xa0[IDi],LevelScheme`Data`xa0[IDf]}+DXCOfXU/@{Posni,Posnf},
(Posni=!=Automatic)&&(Posnf===Automatic),
{LevelScheme`Data`xa0[IDi],LevelScheme`Data`xa0[IDi]}+DXCOfXU/@{Posni,Posni},
(Posni===Automatic)&&(Posnf=!=Automatic),
{LevelScheme`Data`xa0[IDf],LevelScheme`Data`xa0[IDf]}+DXCOfXU/@{Posnf,Posnf},
True,
ErrorMessage[Trans::twoautos]
];
yi=If[FromWing/.FullOpts,LevelScheme`Data`WingEnergy[IDi],LevelScheme`Data`Energy[IDi]];
yf=If[ToWing/.FullOpts,LevelScheme`Data`WingEnergy[IDf],LevelScheme`Data`Energy[IDf]];
PI={xi,yi};
Pf={xf,yf};

Trans[PUOfPC@PI,PUOfPC@Pf,FullOpts]

];
Trans[IDi_?LevelIdentifierQ,Posni:(_?NumericQ|Automatic),IDf_?LevelIdentifierQ,Posnf:(_?NumericQ|Automatic),Opts___?OptionQ]:=Trans[IDi,IDf,EndPositions->{Posni,Posnf},Opts];


BasicLabel[P_,Contents_,Opts___?OptionQ] := Module[
{FullOpts=Flatten[{Opts}]},

MakeText[Contents,P,0,
(* pass on ShowText, Offset, Nudge, Orientation, Background, font style parameters, and Layer from FullOpts*)
FullOpts 
]
];


ManualLabel[P_,Contents_,Opts___?OptionQ] :=Module[
{
FullOpts=RealizeOptions[ManualLabel,Opts]
},

CheckInScheme[];
BasicLabel[PCOfPU[P],Contents,Offset->GetAutoOption[Offset,{0,0},FullOpts],FullOpts]
];   


BandLabel[ID_?LevelIdentifierQ,Contents_,Opts___?OptionQ] := Module[
{
FullOpts=RealizeOptions[BandLabel,Opts]
},
CheckInScheme[];
CheckLevel[ID];
BasicLabel[{(LevelScheme`Data`xa[ID]+LevelScheme`Data`xb[ID])/2,LevelScheme`Data`Energy[ID]},Contents,Offset->GetAutoOption[Offset,{0,+1},FullOpts],FullOpts]
];

BandLabel[ID_?LevelIdentifierQ,Posn_?NumericQ,Contents_,Opts___?OptionQ] := Module[
{
FullOpts=RealizeOptions[BandLabel,Opts]
},

CheckInScheme[];
CheckLevel[ID];
BasicLabel[{LevelScheme`Data`xa0[ID]+DXCOfXU[Posn],LevelScheme`Data`Energy[ID]},Contents,Offset->GetAutoOption[Offset,{0,+1},FullOpts],FullOpts]
];

ScaledLabel[Pr_,Contents_,Opts___?OptionQ] :=Module[
{
FullOpts=RealizeOptions[ScaledLabel,Opts]
},

CheckInScheme[];
BasicLabel[PCOfPS[Pr],Contents,Offset->GetAutoOption[Offset,{0,0},FullOpts],FullOpts]
];


BasicLevelLabel[ID_?LevelIdentifierQ,Posn:(Left|Right),Contents_,FullOpts_List] := Module[
{
P0,P1,P2,PLabel,Sense,NeedLine,GapValues
},

CheckOption[CallOutVector,None|{_?NumericQ,_?NumericQ},FullOpts];
CheckOption[Gap,_?NumericQ|{_?NumericQ,_?NumericQ},FullOpts];
NeedLine=(CallOutVector/.FullOpts)=!=None;

GapValues=UpgradeScalarXY[Gap/.FullOpts];
Sense=Switch[Posn,Left,-1,Right,+1];

P0 = Switch[Posn,
Left,
{LevelScheme`Data`xa[ID],LevelScheme`Data`EnergyL[ID]},
Right,
{LevelScheme`Data`xb[ID],LevelScheme`Data`EnergyR[ID]}
];
If[NeedLine,
P1 =P0+Sense*{DXCOfXA @GapValues[[1]],0};
P2 =P1+DPCOfPA@(CallOutVector/.FullOpts);
PLabel =P2+Sense*{DXCOfXA @GapValues[[2]],0},
PLabel=P0+Sense*{DXCOfXA @GapValues[[2]],0}
];

{

(* Optional call-out line *)
If[NeedLine,
MakeOutline[{Line[{P1,P2}]},FullOpts]
],

(* Label *)
BasicLabel[PLabel,Contents,Offset->GetAutoOption[Offset,{-Sense,0},FullOpts],FullOpts]
}
];
BasicLevelLabel[ID_?LevelIdentifierQ,Posn:(Bottom|Top),Contents_,FullOpts_List] := Module[
{
P0,P1,P2,PLabel,Sense,NeedLine,GapValues
},

CheckOption[CallOutVector,None|{_?NumericQ,_?NumericQ},FullOpts];
CheckOption[Gap,_?NumericQ|{_?NumericQ,_?NumericQ},FullOpts];

Sense=Switch[Posn,Bottom,-1,Top,+1];

{
(* Label *)
BasicLabel[{(LevelScheme`Data`xa[ID]+LevelScheme`Data`xb[ID])/2,LevelScheme`Data`Energy[ID]},Contents,Offset->GetAutoOption[Offset,{0,-Sense},FullOpts],FullOpts]
}
];
LevelLabel[ID_?LevelIdentifierQ,Posn:(Left|Right|Top|Bottom),Contents_,Opts___?OptionQ] := Module[
{
FullOpts=RealizeOptions[LevelLabel,Opts]
},
CheckInScheme[];
CheckLevel[ID];
BasicLevelLabel[ID,Posn,Contents,FullOpts]
];


BasicLabel3D[P_,Contents_,FullOpts_List] := Module[
{},
MakeText3D[Contents,P,0,FullOpts ]
];


ManualLabel3D[P_,Contents_,Opts___?OptionQ] :=Module[
{
FullOpts=RealizeOptions[ManualLabel3D,Opts]
},
BasicLabel3D[P,Contents,OptionsUnion[Offset->GetAutoOption[Offset,{0,0},FullOpts],FullOpts]]
];   


BasicLine[Points_List,FullOpts_List]:=Module[
{},

(* option processing *)

CheckOption[HeadLength,_?NumericQ,FullOpts];
CheckOption[HeadLip,_?NumericQ,FullOpts];
CheckOption[ShowHead,True|False,FullOpts];
CheckOption[ShowTail,True|False,FullOpts];

{

(* outline *)

MakeOutline[
{
Line[Points]
},
FullOpts],

If[ShowHead/.FullOpts,
MakeOutline[
{
Line[PCOfPA/@ArrowHeadPoints[PAOfPC/@Take[Points,-2],(HeadLength/.FullOpts),(HeadLip/.FullOpts)]]
},
Dashing->None,FullOpts
]
],

If[ShowTail/.FullOpts,
MakeOutline[
{
Line[PCOfPA/@ArrowHeadPoints[Reverse@PAOfPC/@Take[Points,2],(HeadLength/.FullOpts),(HeadLip/.FullOpts)]]
},
Dashing->None,FullOpts
]
],

(* text *)
BasicLineAnnotations[Points,FullOpts]

}
];
SchemeLine[Points_List,Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[SchemeLine,Opts]
},
CheckInScheme[];
BasicLine[PCOfPU/@Points,FullOpts]
];


BasicPolygon[Points_List,FullOpts_List]:=Module[
{},

{

(* Fill *)

MakeFill[
{
Polygon[Points]
},
FullOpts],

(* Outline *)

MakeOutline[
{
Line[Append[Points,First[Points]]]
},
FullOpts]

}
];
SchemePolygon[Points_List,Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[SchemePolygon,Opts]
},
CheckInScheme[];
BasicPolygon[PCOfPU/@Points,FullOpts]
];


BasicBox[{{x1_,x2_},{y1_,y2_}},FullOpts_List]:=Module[
{},

{

(* Fill *)
MakeFill[
{
Polygon[{{x1,y1},{x1,y2},{x2,y2},{x2,y1}}]
},
FullOpts],

(* Outline *)

MakeOutline[
{
Line[{{x1,y1},{x1,y2},{x2,y2},{x2,y1},{x1,y1}}]
},
FullOpts],

(* Labels *)

MakeText[(LabL/.FullOpts), {x1,(y1+y2)/2},0,
ShowText->(ShowLabL/.FullOpts),
Offset->GetAutoOption[OffsetL,{+1,0},FullOpts],
Nudge->(NudgeL/.FullOpts),
Orientation->(OrientationL/.FullOpts),
Background->(BackgroundL/.FullOpts),
FullOpts 
],

MakeText[(LabR/.FullOpts),{x2,(y1+y2)/2},0,
ShowText->(ShowLabR/.FullOpts),
Offset->GetAutoOption[OffsetR,{-1,0},FullOpts],
Nudge->(NudgeR/.FullOpts),
Orientation->(OrientationR/.FullOpts),
Background->(BackgroundR/.FullOpts),
FullOpts 
],

MakeText[(LabC/.FullOpts),{(x1+x2)/2,(y1+y2)/2},0,
ShowText->(ShowLabC/.FullOpts),
Offset->GetAutoOption[OffsetC,{0,0},FullOpts],
Nudge->(NudgeC/.FullOpts),
Orientation->(OrientationC/.FullOpts),
Background->(BackgroundC/.FullOpts),
FullOpts 
],

MakeText[(LabT/.FullOpts),{(x1+x2)/2,y2},0,
ShowText->(ShowLabT/.FullOpts),
Offset->GetAutoOption[OffsetT,{0,-1},FullOpts],
Nudge->(NudgeT/.FullOpts),
Orientation->(OrientationT/.FullOpts),
Background->(BackgroundT/.FullOpts),
FullOpts 
],

MakeText[(LabB/.FullOpts),{(x1+x2)/2,y1},0,
ShowText->(ShowLabB/.FullOpts),
Offset->GetAutoOption[OffsetB,{0,+1},FullOpts],
Nudge->(NudgeB/.FullOpts),
Orientation->(OrientationB/.FullOpts),
Background->(BackgroundB/.FullOpts),
FullOpts 
]

}
];
SchemeBox[{{x1_?NumericQ,x2_?NumericQ},{y1_?NumericQ,y2_?NumericQ}},Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[SchemeBox,Opts]
},
CheckInScheme[];
BasicBox[{XCOfXU/@{x1,x2},YCOfYU/@{y1,y2}},FullOpts]
];
SchemeBox[{x1_?NumericQ,y1_?NumericQ},{x2_?NumericQ,y2_?NumericQ},Opts___?OptionQ]:=SchemeBox[{{x1,x2},{y1,y2}},Opts];
SchemeSquare[P:{_?NumericQ,_?NumericQ},R_?RadiusQ,Opts___?OptionQ]:=Module[
{
PC,xc,yc,RC,xr,yr,
FullOpts=RealizeOptions[SchemeBox,Opts]
},
CheckInScheme[];
PC=PCOfPU@P;
RC=ConvertRadiusToCanvas@R;
If[RC===None,ErrorMessage[SchemeSquare::badr,R]];

{xc,yc}=PC;
{xr,yr}=RC;
BasicBox[{{xc-xr,xc+xr},{yc-yr,yc+yr}},FullOpts]
];


BasicCircle[P:{_?NumericQ,_?NumericQ},R:{_?NumericQ,_?NumericQ},{theta1_?NumericQ,theta2_?NumericQ},FullOpts_List]:=Module[
{OptPosnX,OptBufferX,theta,RX,PX,AngleX},

(* option processing *)

CheckOption[HeadLength,_?NumericQ,FullOpts];
CheckOption[HeadLip,_?NumericQ,FullOpts];
CheckOption[ShowHead,True|False,FullOpts];
CheckOption[ShowTail,True|False,FullOpts];
CheckOption[PosnX,Automatic|(_?NumericQ),FullOpts];

{

(* fill *)

MakeFill[
{
Disk[P,R,{theta1,theta2}]
},
FullOpts],

(* outline *)

MakeOutline[
{
Circle[P,R,{theta1,theta2}]
},
FullOpts],

If[ShowHead/.FullOpts,
MakeOutline[
{
Line[PCOfPA/@ArrowHeadPoints[PAOfPC[P+R*{Cos[theta2],Sin[theta2]}],VectorArcTan[-DPAOfPC[R*{Sin[theta2],-Cos[theta2]}]],(HeadLength/.FullOpts),(HeadLip/.FullOpts)]]
},
Dashing->None,FullOpts
]
],

If[ShowTail/.FullOpts,
MakeOutline[
{
Line[PCOfPA/@ArrowHeadPoints[PAOfPC[P+R*{Cos[theta1],Sin[theta1]}],VectorArcTan[+DPAOfPC[R*{Sin[theta1],-Cos[theta1]}]],(HeadLength/.FullOpts),(HeadLip/.FullOpts)]]
},
Dashing->None,FullOpts
]
],

(* labels *)

MakeText[(LabL/.FullOpts),P+R.{{-1,0},{0,0}},0,
ShowText->(ShowLabL/.FullOpts),
Offset->GetAutoOption[OffsetL,{+1,0},FullOpts],
Nudge->(NudgeL/.FullOpts),
Orientation->(OrientationL/.FullOpts),
Background->(BackgroundL/.FullOpts),
FullOpts 
],

MakeText[(LabR/.FullOpts),P+R.{{+1,0},{0,0}},0,
ShowText->(ShowLabR/.FullOpts),
Offset->GetAutoOption[OffsetR,{-1,0},FullOpts],
Nudge->(NudgeR/.FullOpts),
Orientation->(OrientationR/.FullOpts),
Background->(BackgroundR/.FullOpts),
FullOpts 
],

MakeText[(LabC/.FullOpts),P,0,
ShowText->(ShowLabC/.FullOpts),
Offset->GetAutoOption[OffsetC,{0,0},FullOpts],
Nudge->(NudgeC/.FullOpts),
Orientation->(OrientationC/.FullOpts),
Background->(BackgroundC/.FullOpts),
FullOpts 
],

MakeText[(LabT/.FullOpts),P+R.{{0,0},{0,+1}},0,
ShowText->(ShowLabT/.FullOpts),
Offset->GetAutoOption[OffsetT,{0,-1},FullOpts],
Nudge->(NudgeT/.FullOpts),
Orientation->(OrientationT/.FullOpts),
Background->(BackgroundT/.FullOpts),
FullOpts 
],

MakeText[(LabB/.FullOpts),P+R.{{0,0},{0,-1}},0,
ShowText->(ShowLabB/.FullOpts),
Offset->GetAutoOption[OffsetB,{0,+1},FullOpts],
Nudge->(NudgeB/.FullOpts),
Orientation->(OrientationB/.FullOpts),
Background->(BackgroundB/.FullOpts),
FullOpts 
],

OptPosnX=GetAutoOption[PosnX,0.5,FullOpts];
OptBufferX=GetAutoOption[BufferX,
Switch[(OrientationX/.FullOpts),
Automatic,1.1,
Inverted,1.1,
Horizontal,0,
Vertical,0,
_, 1.1
],
FullOpts
];
theta=Interpolate[0,1,theta1,theta2,OptPosnX];
RX=R*{Cos[theta],Sin[theta]};
AngleX=VectorArcTan[DPAOfPC[R*{Sin[theta],-Cos[theta]}]];
PX=P+RX+DPCOfPA[((Thickness/.FullOpts)/2+OptBufferX/2*(FontSize/.FullOpts))*RX/VectorLength[RX]];
MakeText[(LabX/.FullOpts),PX,AngleX,
ShowText->(ShowLabX/.FullOpts),
Offset->GetAutoOption[OffsetX,{0,0},FullOpts],
Nudge->(NudgeX/.FullOpts),
Orientation->(OrientationX/.FullOpts),
Background->(BackgroundX/.FullOpts),
FullOpts 
]

}
];
SchemeCircle[P:{_?NumericQ,_?NumericQ},R_?RadiusQ,{theta1_?NumericQ,theta2_?NumericQ},Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[SchemeCircle,Opts],
RC
},

CheckInScheme[];

RC=ConvertRadiusToCanvas[R];
If[RC===None,ErrorMessage[SchemeCircle::badr,R]];

BasicCircle[PCOfPU[P],RC,{theta1,theta2},FullOpts]
];
SchemeCircle[P:{_?NumericQ,_?NumericQ},R_?RadiusQ,Opts___?OptionQ]:=SchemeCircle[P,R,{0,2*Pi},Opts];


BasicEllipse[P:{_?NumericQ,_?NumericQ},R:{a_?NumericQ,b_?NumericQ},theta0_?NumericQ,{theta1_?NumericQ,theta2_?NumericQ},Closed:(True|False),FullOpts_List]:=Module[
{OptPosnX,OptBufferX,theta,r,RX,PX,AngleX,Points},

(* option processing *)

CheckOption[HeadLength,_?NumericQ,FullOpts];
CheckOption[HeadLip,_?NumericQ,FullOpts];
CheckOption[ShowHead,True|False,FullOpts];
CheckOption[ShowTail,True|False,FullOpts];
CheckOption[PosnX,Automatic|(_?NumericQ),FullOpts];

(* TO DO: validity checks on angles *)
If[2*Pi/(PlotPoints/.FullOpts)>(theta2-theta1),ErrorMessage[]];

Points=Table[
r=Sqrt[a^2*b^2/(a^2*Sin[theta]^2+b^2*Cos[theta]^2)];
P+DPCOfPU@{r*Cos[theta+theta0],r*Sin[theta+theta0]},
{theta,theta1,theta2,2*Pi/(PlotPoints/.FullOpts)}
];

{

(* fill *)

MakeFill[
{
Polygon[If[Closed,Points,Append[Points,P]]]
},
FullOpts
],

(* outline *)

MakeOutline[
{
Line[If[Closed,Append[Points,First[Points]],Points]]
},
FullOpts
],

(* TO DO: Implement arrowheads and labels *)

If[ShowHead/.FullOpts,
MakeOutline[
{
},
Dashing->None,FullOpts
]
],

If[ShowTail/.FullOpts,
MakeOutline[
{
},
Dashing->None,FullOpts
]
],

(* labels *)

MakeText[(LabL/.FullOpts),P+R.{{-1,0},{0,0}},0,
ShowText->(ShowLabL/.FullOpts),
Offset->GetAutoOption[OffsetL,{+1,0},FullOpts],
Nudge->(NudgeL/.FullOpts),
Orientation->(OrientationL/.FullOpts),
Background->(BackgroundL/.FullOpts),
FullOpts 
],

MakeText[(LabR/.FullOpts),P+R.{{+1,0},{0,0}},0,
ShowText->(ShowLabR/.FullOpts),
Offset->GetAutoOption[OffsetR,{-1,0},FullOpts],
Nudge->(NudgeR/.FullOpts),
Orientation->(OrientationR/.FullOpts),
Background->(BackgroundR/.FullOpts),
FullOpts 
],

MakeText[(LabC/.FullOpts),P,0,
ShowText->(ShowLabC/.FullOpts),
Offset->GetAutoOption[OffsetC,{0,0},FullOpts],
Nudge->(NudgeC/.FullOpts),
Orientation->(OrientationC/.FullOpts),
Background->(BackgroundC/.FullOpts),
FullOpts 
],

MakeText[(LabT/.FullOpts),P+R.{{0,0},{0,+1}},0,
ShowText->(ShowLabT/.FullOpts),
Offset->GetAutoOption[OffsetT,{0,-1},FullOpts],
Nudge->(NudgeT/.FullOpts),
Orientation->(OrientationT/.FullOpts),
Background->(BackgroundT/.FullOpts),
FullOpts 
],

MakeText[(LabB/.FullOpts),P+R.{{0,0},{0,-1}},0,
ShowText->(ShowLabB/.FullOpts),
Offset->GetAutoOption[OffsetB,{0,+1},FullOpts],
Nudge->(NudgeB/.FullOpts),
Orientation->(OrientationB/.FullOpts),
Background->(BackgroundB/.FullOpts),
FullOpts 
],

OptPosnX=GetAutoOption[PosnX,0.5,FullOpts];
OptBufferX=GetAutoOption[BufferX,
Switch[(OrientationX/.FullOpts),
Automatic,1.1,
Inverted,1.1,
Horizontal,0,
Vertical,0,
_, 1.1
],
FullOpts
];
theta=Interpolate[0,1,theta1,theta2,OptPosnX];
RX=R*{Cos[theta],Sin[theta]};
AngleX=VectorArcTan[DPAOfPC[R*{Sin[theta],-Cos[theta]}]];
PX=P+RX+DPCOfPA[((Thickness/.FullOpts)/2+OptBufferX/2*(FontSize/.FullOpts))*RX/VectorLength[RX]];
MakeText[(LabX/.FullOpts),PX,AngleX,
ShowText->(ShowLabX/.FullOpts),
Offset->GetAutoOption[OffsetX,{0,0},FullOpts],
Nudge->(NudgeX/.FullOpts),
Orientation->(OrientationX/.FullOpts),
Background->(BackgroundX/.FullOpts),
FullOpts 
]

}
];
SchemeEllipse[P:{_?NumericQ,_?NumericQ},R:{_?NumericQ,_?NumericQ},theta0_?NumericQ,{theta1_?NumericQ,theta2_?NumericQ},Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[SchemeEllipse,Opts]
},

CheckInScheme[];

BasicEllipse[PCOfPU[P],R,theta0,{theta1,theta2},False,FullOpts]
];
SchemeEllipse[P:{_?NumericQ,_?NumericQ},R:{_?NumericQ,_?NumericQ},theta0_?NumericQ,Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[SchemeEllipse,Opts]
},

CheckInScheme[];

BasicEllipse[PCOfPU[P],R,theta0,{0,2*Pi},True,FullOpts]
];


SchemeArrow[RawNodes:{PI:{_?NumericQ,_?NumericQ},(_?ArrowNodeQ)...,Pf:{_?NumericQ,_?NumericQ}},Opts___?OptionQ] := Module[
{
FullOpts=RealizeOptions[SchemeArrow,Opts],
Nodes,R,P
},

CheckInScheme[];
CheckOption[Kink,None,FullOpts];

Nodes=Replace[
RawNodes,
{
P:{_?NumericQ,_?NumericQ}:>PCOfPU@P,
FromHead[R_]:>(PCOfPU@Pf+ConvertRadiusToCanvas[R]),
FromTail[R_]:>(PCOfPU@PI+ConvertRadiusToCanvas[R])
},
1
];

BasicArrow[SchemeArrow,Nodes,FullOpts]
];
SchemeArrow[PI:{_?NumericQ,_?NumericQ},Pf:{_?NumericQ,_?NumericQ},Opts___?OptionQ] := Module[
{
FullOpts=RealizeOptions[SchemeArrow,Opts],
RawNodes,Nodes,R,P
},

CheckInScheme[];
CheckOption[Kink,None|_?ArrowNodeQ|{(_?ArrowNodeQ)...},FullOpts];

RawNodes=Join[
{PI},
Switch[
(Kink/.FullOpts),
None,{},
_?ArrowNodeQ,{(Kink/.FullOpts)},
{(_?ArrowNodeQ)...},(Kink/.FullOpts)
],
{Pf}
];
Nodes=Replace[
RawNodes,
{
P:{_?NumericQ,_?NumericQ}:>PCOfPU@P,
FromHead[R_]:>(PCOfPU@Pf+ConvertRadiusToCanvas[R]),
FromTail[R_]:>(PCOfPU@PI+ConvertRadiusToCanvas[R])
},
1
];

BasicArrow[SchemeArrow,Nodes,FullOpts]
];


BasicSchemeBracket[Caller_Symbol,{{x1_,x2_},{y1_,y2_}},Axis:(1|2|3|4),FullOpts_List]:=Module[
{
Segment,HalfWidthForLabels,Buffer,Posn,P,
LabelGraphics,
ArrowHeadSign,
Points
},

(* calculate geometry *)
Segment=Switch[Axis,
1,{{x1,y1},{x2,y1}},
2,{{x1,y1},{x1,y2}},
3,{{x1,y2},{x2,y2}},
4,{{x2,y1},{x2,y2}}
];
ArrowHeadSign=Switch[Axis,
1|4,+1,
2|3,-1
];

(* construct axis label *)
(* basic spacing provided by Offset, additional by Buffer *)
HalfWidthForLabels=(Thickness/.FullOpts)/2;
Buffer=GetAutoOption[Switch[Axis,1,BufferB,2,BufferL,3,BufferT,4,BufferR],1.1,FullOpts];
Posn=GetAutoOption[Switch[Axis,1,PosnB,2,PosnL,3,PosnT,4,PosnR],0.5,FullOpts];
P=PCOfPA@ArrowPoint[Caller,PAOfPC/@Segment,AtUserPosition,Posn,Switch[Axis,1|4,-1,2|3,+1]*(HalfWidthForLabels+Buffer/2*(FontSize/.FullOpts))];

LabelGraphics={
Switch[
Axis,
1,
MakeText[(LabB/.FullOpts),P,0,
ShowText->(ShowLabB/.FullOpts),
Offset->GetAutoOption[OffsetB,{0,0},FullOpts],
Nudge->(NudgeB/.FullOpts),
Orientation->(OrientationB/.FullOpts),
Background->(BackgroundB/.FullOpts),
FullOpts 
],
2,
MakeText[(LabL/.FullOpts),P,-Pi/2,
ShowText->(ShowLabL/.FullOpts),
Offset->GetAutoOption[OffsetL,{0,0},FullOpts],
Nudge->(NudgeL/.FullOpts),
Orientation->(OrientationL/.FullOpts),
Background->(BackgroundL/.FullOpts),
FullOpts 
],
3,
MakeText[(LabT/.FullOpts),P,0,
ShowText->(ShowLabT/.FullOpts),
Offset->GetAutoOption[OffsetT,{0,0},FullOpts],
Nudge->(NudgeT/.FullOpts),
Orientation->(OrientationT/.FullOpts),
Background->(BackgroundT/.FullOpts),
FullOpts 
],
4,
MakeText[(LabR/.FullOpts),P,-Pi/2,
ShowText->(ShowLabR/.FullOpts),
Offset->GetAutoOption[OffsetR,{0,0},FullOpts],
Nudge->(NudgeR/.FullOpts),
Orientation->(OrientationR/.FullOpts),
Background->(BackgroundR/.FullOpts),
FullOpts 
]
]
};

(* Combine ticks with axis line *)
Points=Join[
Take[PCOfPA/@ArrowHeadPoints[PAOfPC/@Reverse@Segment,-HeadLength/.FullOpts,HeadLip/.FullOpts],-1*ArrowHeadSign],
Segment,
Take[PCOfPA/@ArrowHeadPoints[PAOfPC/@Segment,-HeadLength/.FullOpts,HeadLip/.FullOpts],+1*ArrowHeadSign]
];
Flatten[{
(* axis line *)
MakeOutline[{Line[Points]},FullOpts],
(* labels *)
LabelGraphics
}]

];
SchemeBracket[Side:(Bottom|Top),{xa_?NumericQ,xb_?NumericQ},y_?NumericQ,Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[SchemeBracket,Opts]
},

CheckInScheme[];

Switch[
Side,
Bottom,
BasicSchemeBracket[SchemeBracket,{{XCOfXU[xa],XCOfXU[xb]},{YCOfYU[y],Null}},1,FullOpts],
Top,
BasicSchemeBracket[SchemeBracket,{{XCOfXU[xa],XCOfXU[xb]},{Null,YCOfYU[y]}},3,FullOpts]
]
];
SchemeBracket[Side:(Left|Right),x_?NumericQ,{ya_?NumericQ,yb_?NumericQ},Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[SchemeBracket,Opts]
},

CheckInScheme[];

Switch[
Side,
Left,
BasicSchemeBracket[SchemeBracket,{{XCOfXU[x],Null},{YCOfYU[ya],YCOfYU[yb]}},2,FullOpts],
Right,
BasicSchemeBracket[SchemeBracket,{{Null,XCOfXU[x]},{YCOfYU[ya],YCOfYU[yb]}},4,FullOpts]
]
];
SchemeBracket[Side:(Bottom|Top),{IDi_?LevelIdentifierQ,IDf_?LevelIdentifierQ},y_?NumericQ,Opts___?OptionQ]:=Module[
{},

CheckInScheme[];
CheckLevel[IDi];
CheckLevel[IDf];

SchemeBracket[Side,{XUOfXC@LevelScheme`Data`xa[IDi],XUOfXC@LevelScheme`Data`xb[IDf]},y,Opts]
];
SchemeBracket[Side:(Left|Right),x_?NumericQ,{IDi_?LevelIdentifierQ,IDf_?LevelIdentifierQ},Opts___?OptionQ]:=Module[
{},

CheckInScheme[];
CheckLevel[IDi];
CheckLevel[IDf];

SchemeBracket[Side,x,{YUOfYC@LevelScheme`Data`Energy[IDi],YUOfYC@LevelScheme`Data`Energy[IDf]},Opts]
];



ArrowHeadPoints3D[{P1_,P2_},HeadLength_,HeadLip_,HeadAngle_] := Module[
{v,Normv,u,
alpha,beta,gamma,
R
},
v=P2-P1;
Normv=Sqrt[Plus@@((#^2&)/@v)];
u=If[Normv==0.,{0,0,1},v/Normv];
alpha=HeadAngle;
beta=ArcCos[u[[3]]];
gamma=Pi/2-VectorArcTan[{u[[1]],u[[2]]}];
R=RotationMatrix3D[alpha,beta,gamma];
{
P2+R.{+HeadLip,0.,-HeadLength},
P2,
P2+R.{-HeadLip,0.,-HeadLength}
}
];
BasicArrow3D[Caller_Symbol,PI_,Pf_,HeadAngle_,FullOpts_List] := Module[
{OptWidth,OptHeadLength,OptHeadLip,OptThickness,Segment,TailSegment,PC,Art},

CheckOption[ArrowType,LineArrow,FullOpts];
CheckOption[HeadLength,_?NumericQ,FullOpts];
CheckOption[HeadLip,_?NumericQ,FullOpts];
CheckOption[ShowHead,True|False,FullOpts];
CheckOption[ShowTail,True|False,FullOpts];
CheckOption[PosnC,Automatic|(_?NumericQ),FullOpts];

(* calculate arrow geometry *)
OptWidth=(Width/.FullOpts);
OptHeadLength=(HeadLength/.FullOpts);
OptHeadLip=(HeadLip/.FullOpts);
OptThickness=(Thickness/.FullOpts);
Segment={PI,Pf};
TailSegment=Segment;

PC=PI+(Pf-PI)*GetAutoOption[PosnC,0.5,FullOpts];

Art={

(* main segment *)
MakeOutline3D[{Line[Segment]},FullOpts] ,

(* head *)
If[ShowHead/.FullOpts,
MakeOutline3D[{Line[ArrowHeadPoints3D[Segment,OptHeadLength,OptHeadLip,HeadAngle]]},Dashing->None,FullOpts],
{}
],

(* tail *)
If[ShowTail/.FullOpts,
MakeOutline3D[{Line[ArrowHeadPoints3D[Reverse@TailSegment,OptHeadLength,OptHeadLip,HeadAngle]]},Dashing->None,FullOpts],
{}
],

(* label *)
MakeText3D[(LabC/.FullOpts), PC,0,
ShowText->(ShowLabC/.FullOpts),
Offset->GetAutoOption[OffsetC,{0,0},FullOpts],
Orientation->(OrientationC/.FullOpts),
Background->(BackgroundC/.FullOpts),
FullOpts 
]

};

Flatten[Art]
];


SchemeArrow3D[PI:{_?NumericQ,_?NumericQ,_?NumericQ},Pf:{_?NumericQ,_?NumericQ,_?NumericQ},HeadAngle:(_?NumericQ):0,Opts___?OptionQ] :=Module[
{
FullOpts=RealizeOptions[SchemeArrow3D,Opts]
},
BasicArrow3D[SchemeArrow3D,PI,Pf,HeadAngle,FullOpts]
];   


BasicLine3D[Points_List,FullOpts_List] := Module[
{},
{
(* outline *)
MakeOutline3D[
{
Line[Points]
},
FullOpts]
}
];


SchemeLine3D[Points:{{_?NumericQ,_?NumericQ,_?NumericQ}...},Opts___?OptionQ] :=Module[
{
FullOpts=RealizeOptions[SchemeLine3D,Opts]
},
BasicLine3D[Points,FullOpts]
];   


SchemeScaleP[Offset[DPA:{_?NumericQ,_?NumericQ},GeneralP_]]:=DPCOfPA[DPA]+SchemeScaleP[GeneralP];
SchemeScaleP[Scaled[DPS:{_?NumericQ,_?NumericQ},PU:{_?NumericQ,_?NumericQ}]]:=DPCOfPS[DPS]+PCOfPU[PU];
SchemeScaleP[Scaled[PS:{_?NumericQ,_?NumericQ}]]:=PCOfPS[PS];
SchemeScaleP[PU:{_?NumericQ,_?NumericQ}]:=PCOfPU[PU];
SchemeScaleP[x_]:=ErrorMessage[RawGraphics::badpoint,Expr];


(* basic case --Graphics with only primatives list as argument *)
RawGraphics[GraphicsSeq:(Graphics[_List]...),Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[RawGraphics,Opts],
ScaledGraphicsList,ClippedGraphicsList,Result
},

CheckInScheme[];
CheckOption[ClipToRectangle,True|False|{{_?NumericQ,_?NumericQ},{_?NumericQ,_?NumericQ}},FullOpts];
CheckOption[Show,True|False,FullOpts];
CheckOption[Debug,True|False,FullOpts];

If[Debug/.FullOpts,Print["RawGraphics: Given"]];
If[Debug/.FullOpts,Print[First/@{GraphicsSeq}]];

If[Debug/.FullOpts,Print["RawGraphics: Scaling"]];
ScaledGraphicsList=(TransformGraphics[#,(SchemeScaleP[#]&)]&)/@{GraphicsSeq};
If[Debug/.FullOpts,Print[First/@ScaledGraphicsList]];

If[Debug/.FullOpts,Print["RawGraphics: Cropping ",$RegionRange]];
ClippedGraphicsList=Switch[
ClipToRectangle/.FullOpts,
True,(ClipToRectangle[$RegionRange,#]&)/@ScaledGraphicsList,
{{_?NumericQ,_?NumericQ},{_?NumericQ,_?NumericQ}},(ClipToRectangle[ConvertCoordinate[RegionCoords,CanvasCoords,C,ClipToRectangle/.FullOpts],#]&)/@ScaledGraphicsList,
False,ScaledGraphicsList
];
If[Debug/.FullOpts,Print[First/@ClippedGraphicsList]];

If[Debug/.FullOpts,Print["RawGraphics: Making"]];
Result=MakeRawGraphics[First/@ClippedGraphicsList,FullOpts];
If[Debug/.FullOpts,Print[Result]];
Result
];

(* typecast ContourGraphics or DensityGraphics to Graphics *)
RawGraphics[X___,G:(_ContourGraphics|_DensityGraphics),Y___]:=Module[
{},
RawGraphics[X,Graphics[G],Y]
];
(* strip graphics options *)
RawGraphics[X___,Graphics[Arg_,__?OptionQ],Y___]:=Module[
{},
RawGraphics[X,Graphics[Arg],Y]
];
(* discard graphics with no argument *)
RawGraphics[X___,Graphics[],Y___]:=Module[
{},
Message[RawGraphics::empty];
RawGraphics[X,Y]
];
(* wrap any non-list first element of graphics object -- syntax not documented by Mathematica but supported by show and can occur in Graphics cast of DensityGraphics *)
RawGraphics[X___,Graphics[Primative_/;(Head[Primative]=!=List)],Y___]:=Module[
{},
RawGraphics[X,Graphics[{Primative}],Y]
];
(* discard graphics with more than one non-option argument *)
RawGraphics[X___,Graphics[_,___,Arg/;(!OptionQ[Arg]),___],Y___]:=Module[
{},
Message[RawGraphics::multiarg];
RawGraphics[X,Y]
];


RawGraphics3D[GraphicsSeq:(___?Graphics3DQ),Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[RawGraphics3D,Opts]
},

CheckInScheme[];
CheckOption[Show,True|False,FullOpts];
CheckOption[Debug,True|False,FullOpts];

MakeRawGraphics3D[First/@{GraphicsSeq},FullOpts]
];


Graphics3DQ[Graphics3D[_List]]=True;
Graphics3DQ[Graphics3D[_List,_?FlatOptionListQ]]=True;
Graphics3DQ[_]=False;


(* drop nongraphical *)
CombineGraphics3D[{U___,X_/;(!MatchQ[X,(_?Graphics3DQ)|(_SurfaceGraphics)]),V___}]:=CombineGraphics3D[{U,V}];
(* convert SurfaceGraphics to Graphics3D *)
CombineGraphics3D[{U___,X_SurfaceGraphics,V___}]:=CombineGraphics3D[{U,Graphics3D[X],V}];
(* do combination -- primatives quarantined in sublists *)
CombineGraphics3D[GList:{___?Graphics3DQ}]:=Graphics3D[First/@GList];


AxisRotationMatrix[1,theta_,Sign:(+1|-1)]:={{1,0,0},{0,Cos[theta],-Sign*Sin[theta]},{0,+Sign*Sin[theta],Cos[theta]}};
AxisRotationMatrix[2,theta_,Sign:(+1|-1)]:={{Cos[theta],0,+Sign*Sin[theta]},{0,1,0},{-Sign*Sin[theta],0,Cos[theta]}};
AxisRotationMatrix[3,theta_,Sign:(+1|-1)]:={{Cos[theta],-Sign*Sin[theta],0},{+Sign*Sin[theta],Cos[theta],0},{0,0,1}};


RotationMatrix3DActiveY[{alpha_,beta_,gamma_}]:=AxisRotationMatrix[3,gamma,+1].AxisRotationMatrix[2,beta,+1].AxisRotationMatrix[3,alpha,+1];


SetAttributes[BasicViewPort3D,HoldFirst];
BasicViewPort3D[GList_List,{{x1c_?NumericQ,x2c_?NumericQ},{y1c_?NumericQ,y2c_?NumericQ}},FullOpts_List]:=Module[
{
ScaledGraphicsList,ClippedGraphicsList,Result,
Primatives,RotationMatrix,UsedOptions
},

CheckInScheme[];
CheckOption[Background,None|ColorDirectivePattern,FullOpts];
CheckOption[BackgroundOpacity,_?NumericQ,FullOpts];
CheckOption[Show,True|False,FullOpts];
CheckOption[BlockOptions,{___Symbol},FullOpts];
CheckOption[Debug,True|False,FullOpts];
CheckOption[EulerRotation,None|{_?NumericQ,_?NumericQ,_?NumericQ}];
CheckOption[AxisScaling,Automatic|{_?NumericQ,_?NumericQ,_?NumericQ}];
If[
((AxisScaling/.FullOpts)=!=Automatic)&&((PlotRange/.FullOpts)==Automatic),
ErrorMessage[ViewPort3D::prange]
];

Primatives=BlockOptions[
Union[OptionSymbols3D,(BlockOptions/.FullOpts)],
First[CombineGraphics3D[Flatten[GList]]]
];
If[
(EulerRotation/.FullOpts)=!=None,
RotationMatrix=RotationMatrix3DActiveY[EulerRotation/.FullOpts];
Primatives=First@TransformGraphics[Graphics[Primatives],(RotationMatrix.#&)]
];
If[(Debug/.FullOpts),Print[Primatives//Short]];
UsedOptions=OptionsUnion[
{
If[
(AxisScaling/.FullOpts)===Automatic,
{},
{BoxRatios->(AxisScaling/.FullOpts)*-Subtract@@@(PlotRange/.FullOpts)}
],
LegacyFilterOptions[Graphics3D,FullOpts]
}
];
If[(Debug/.FullOpts),Print[UsedOptions]];

{
(* background *)
If[
(Background/.FullOpts)=!=None,
MakeFill[
{Rectangle[{x1c,y1c},{x2c,y2c}]},
Color->(Background/.FullOpts),Opacity->(BackgroundOpacity/.FullOpts),
ShowFill->True,FillColor->Automatic,FillOpacity->Automatic,ClipToRectangle->False,
FullOpts
]
],

(* contents *)
MakeVerbatim[
{Rectangle[{x1c,y1c},{x2c,y2c},Graphics3D[Primatives,UsedOptions]]},
FullOpts]
}

];


SetAttributes[ViewPort3D,HoldFirst];
ViewPort3D[GList_List,{{x1_?NumericQ,x2_?NumericQ},{y1_?NumericQ,y2_?NumericQ}},Opts___?OptionQ]:=Module[
{FullOpts=RealizeOptions[ViewPort3D,Opts]},
BasicViewPort3D[GList,{XCOfXU/@{x1,x2},YCOfYU/@{y1,y2}},FullOpts]
];
SetAttributes[ScaledViewPort3D,HoldFirst];
ScaledViewPort3D[GList_List,{{x1s_?NumericQ,x2s_?NumericQ},{y1s_?NumericQ,y2s_?NumericQ}},Opts___?OptionQ]:=Module[
{FullOpts=RealizeOptions[ScaledViewPort3D,Opts]},
BasicViewPort3D[GList,{XCOfXS/@{x1s,x2s},YCOfYS/@{y1s,y2s}},FullOpts]
];


BasicAxis[Caller_Symbol,{{x1_,x2_},{y1_,y2_}},Axis:(1|2|3|4),ShowAxis:(True|False),ShowHead:(True|False),Ticks_List,FullOpts_List]:=Module[
{
Segment,HalfWidthForLabels,Buffer,Posn,P,
TickGraphics,LabelGraphics,
TickData,TickPosn,TickText,TickLengths,TickAttributes,
TickPoint,TickEndPoints,TickOffset
},

(* calculate geometry *)
Segment=Switch[Axis,
1,{{x1,y1},{x2,y1}},
2,{{x1,y1},{x1,y2}},
3,{{x1,y2},{x2,y2}},
4,{{x2,y1},{x2,y2}}
];

(* construct ticks *)
TickGraphics=TableForEach[
{TickPosn,TickText,TickLengths,TickAttributes}=TickData;
If[TickText==="",TickText=None];
Switch[
Axis,
1,
TickPoint={TickPosn,y1};
TickEndPoints={TickPoint+{0,TickLengths[[1]]},TickPoint-{0,TickLengths[[2]]}};
TickOffset={0,+1},
2,
TickPoint={x1,TickPosn};
TickEndPoints={TickPoint+{TickLengths[[1]],0},TickPoint-{TickLengths[[2]],0}};
TickOffset={+1,0},
3,
TickPoint={TickPosn,y2};
TickEndPoints={TickPoint-{0,TickLengths[[1]]},TickPoint+{0,TickLengths[[2]]}};
TickOffset={0,-1},
4,
TickPoint={x2,TickPosn};
TickEndPoints={TickPoint-{TickLengths[[1]],0},TickPoint+{TickLengths[[2]],0}};
TickOffset={-1,0}
];
{
MakeOutline[{
Join[TickAttributes,{Line[TickEndPoints]}]
},
If[Chop[DPAOfPC[Subtract@@TickEndPoints]]=={0,0},ShowLine->False,{}],
Dashing->None,
ShowLine->GetAutoOption[TickShowLine,ShowLine/.FullOpts,FullOpts],
LineColor->GetAutoOption[TickLineColor,LineColor/.FullOpts,FullOpts],
LineOpacity->GetAutoOption[TickLineOpacity,LineOpacity/.FullOpts,FullOpts],
Thickness->GetAutoOption[TickThickness,Thickness/.FullOpts,FullOpts],
FullOpts
],
MakeText[TickText,TickPoint,0,
ShowText->True,
Offset->TickOffset,
Nudge->(TickNudge/.FullOpts),
Orientation->0,
Background->None,
FontFamily->GetAutoOption[TickFontFamily,FontFamily/.FullOpts,FullOpts],
FontSize->GetAutoOption[TickFontSize,FontSize/.FullOpts,FullOpts],
FontWeight->GetAutoOption[TickFontWeight,FontWeight/.FullOpts,FullOpts],
FontSlant->GetAutoOption[TickFontSlant,FontSlant/.FullOpts,FullOpts],
FontTracking->GetAutoOption[TickFontTracking,FontTracking/.FullOpts,FullOpts],
FontColor->GetAutoOption[TickFontColor,FontColor/.FullOpts,FullOpts],
FontOpacity->GetAutoOption[TickFontOpacity,FontOpacity/.FullOpts,FullOpts],
FullOpts (* pass on default color and optional Layer from FullOpts *)
]
},
{TickData,Ticks}
];

(* construct axis label *)
(* basic spacing provided by Offset, additional by Buffer *)
HalfWidthForLabels=(Thickness/.FullOpts)/2;
Buffer=GetAutoOption[Switch[Axis,1,BufferB,2,BufferL,3,BufferT,4,BufferR],1.1,FullOpts];
Posn=GetAutoOption[Switch[Axis,1,PosnB,2,PosnL,3,PosnT,4,PosnR],0.5,FullOpts];
P=PCOfPA@ArrowPoint[Caller,PAOfPC/@Segment,AtUserPosition,Posn,Switch[Axis,1|4,-1,2|3,+1]*(HalfWidthForLabels+Buffer/2*(FontSize/.FullOpts))];

LabelGraphics={
Switch[
Axis,
1,
MakeText[(LabB/.FullOpts),P,0,
ShowText->(ShowLabB/.FullOpts),
Offset->GetAutoOption[OffsetB,{0,0},FullOpts],
Nudge->(NudgeB/.FullOpts),
Orientation->(OrientationB/.FullOpts),
Background->(BackgroundB/.FullOpts),
FullOpts 
],
2,
MakeText[(LabL/.FullOpts),P,-Pi/2,
ShowText->(ShowLabL/.FullOpts),
Offset->GetAutoOption[OffsetL,{0,0},FullOpts],
Nudge->(NudgeL/.FullOpts),
Orientation->(OrientationL/.FullOpts),
Background->(BackgroundL/.FullOpts),
FullOpts 
],
3,
MakeText[(LabT/.FullOpts),P,0,
ShowText->(ShowLabT/.FullOpts),
Offset->GetAutoOption[OffsetT,{0,0},FullOpts],
Nudge->(NudgeT/.FullOpts),
Orientation->(OrientationT/.FullOpts),
Background->(BackgroundT/.FullOpts),
FullOpts 
],
4,
MakeText[(LabR/.FullOpts),P,-Pi/2,
ShowText->(ShowLabR/.FullOpts),
Offset->GetAutoOption[OffsetR,{0,0},FullOpts],
Nudge->(NudgeR/.FullOpts),
Orientation->(OrientationR/.FullOpts),
Background->(BackgroundR/.FullOpts),
FullOpts 
]
]
};

(* Combine ticks with axis line *)
Flatten[{
(* axis line *)
If[ShowAxis,
MakeOutline[{Line[Segment]},FullOpts]
],
(* head *)
If[ShowHead,
MakeOutline[{Line[PCOfPA/@ArrowHeadPoints[PAOfPC/@Segment,HeadLength/.FullOpts,HeadLip/.FullOpts]]},Dashing->None,FullOpts]
],
(* ticks *)
TickGraphics,
(* labels *)
LabelGraphics
}]

];


SchemeAxis[Side:(Bottom|Top),{xa_,xb_},y_,Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[SchemeAxis,Opts],
TickList
},

CheckInScheme[];
CheckOption[ShowTicks,True|False,FullOpts];
CheckOption[ShowTickLabels,True|False,FullOpts];

TickList=Switch[(Ticks/.FullOpts),None,{},_List,Ticks/.FullOpts];
TickList=AugmentTicks[{0.0075,0},{},TickList];
TickList=TransformTicks[XCOfXU,DYCTick,LimitTickRange[{xa,xb},TickList]];
TickList=If[ShowTickLabels/.FullOpts,TickList,StripTickLabels[TickList]];
TickList=If[ShowTicks/.FullOpts,TickList,{}];
Switch[
Side,
Bottom,
BasicAxis[SchemeAxis,{{XCOfXU[xa],XCOfXU[xb]},{YCOfYU[y],Null}},1,True,(ShowHead/.FullOpts),TickList,FullOpts],
Top,
BasicAxis[SchemeAxis,{{XCOfXU[xa],XCOfXU[xb]},{Null,YCOfYU[y]}},3,True,(ShowHead/.FullOpts),TickList,FullOpts]
]
];
SchemeAxis[Side:(Left|Right),x_,{ya_,yb_},Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[SchemeAxis,Opts],
TickList
},

CheckInScheme[];
CheckOption[ShowTicks,True|False,FullOpts];
CheckOption[ShowTickLabels,True|False,FullOpts];

TickList=Switch[(Ticks/.FullOpts),None,{},_List,Ticks/.FullOpts];
TickList=AugmentTicks[{0.01,0},{},TickList];
TickList=TransformTicks[YCOfYU,DXCTick,LimitTickRange[{ya,yb},TickList]];
TickList=If[ShowTickLabels/.FullOpts,TickList,StripTickLabels[TickList]];
TickList=If[ShowTicks/.FullOpts,TickList,{}];

Switch[
Side,
Left,
BasicAxis[SchemeAxis,{{XCOfXU[x],Null},{YCOfYU[ya],YCOfYU[yb]}},2,True,(ShowHead/.FullOpts),TickList,FullOpts],
Right,
BasicAxis[SchemeAxis,{{Null,XCOfXU[x]},{YCOfYU[ya],YCOfYU[yb]}},4,True,(ShowHead/.FullOpts),TickList,FullOpts]
]
];


RangePattern=(Automatic|{_?NumericQ,_?NumericQ});
TickPattern=(None|Automatic|_?TickListQ);


VectorOfQ[x_,p_]:=VectorQ[x,MatchQ[#,p]&];
MatrixOfQ[x_,p_]:=MatrixQ[x,MatchQ[#,p]&];
VectorPattern[p_]:=(_?(VectorOfQ[#,p]&));
MatrixPattern[p_]:=(_?(MatrixOfQ[#,p]&));


UpgradeMultipanelArray[Data_,Sense:Horizontal,{Rows_Integer,Columns_Integer},OptionName_Symbol,EntryPattern_]/;(MatchQ[Data,EntryPattern]):=
UpgradeMultipanelArray[Table[Data,{Columns}],Sense,{Rows,Columns},OptionName,EntryPattern];
UpgradeMultipanelArray[Data_,Sense:Horizontal,{Rows_Integer,Columns_Integer},OptionName_Symbol,EntryPattern_]/;(VectorQ[Data,MatchQ[#,EntryPattern]&]):=
UpgradeMultipanelArray[Table[Data,{Rows}],Sense,{Rows,Columns},OptionName,EntryPattern];
UpgradeMultipanelArray[Data_,Sense:Vertical,{Rows_Integer,Columns_Integer},OptionName_Symbol,EntryPattern_]/;(MatchQ[Data,EntryPattern]):=
UpgradeMultipanelArray[Table[Data,{Rows}],Sense,{Rows,Columns},OptionName,EntryPattern];
UpgradeMultipanelArray[Data_,Sense:Vertical,{Rows_Integer,Columns_Integer},OptionName_Symbol,EntryPattern_]/;(VectorQ[Data,MatchQ[#,EntryPattern]&]):=
UpgradeMultipanelArray[Transpose@Table[Data,{Columns}],Sense,{Rows,Columns},OptionName,EntryPattern];
UpgradeMultipanelArray[Data_,Sense:(Horizontal|Vertical),{Rows_Integer,Columns_Integer},OptionName_Symbol,EntryPattern_]/;(MatrixQ[Data,MatchQ[#,EntryPattern]&]):=
Switch[
Dimensions[Data,2],
{Rows,Columns},
Data,
{1,Columns},
Table[First[Data],{Rows}],
{Rows,1},
Transpose@Table[First[Transpose@Data],{Columns}],
_,
ErrorMessage[Multipanel::num,OptionName]
];


ScalarQ[x_]:=(Head[x]=!=List);
UpgradeMultipanelArray[Data_,Sense:(Horizontal|Vertical),{Rows_Integer,Columns_Integer},OptionName_Symbol]:=UpgradeMultipanelArray[Data,Sense,{Rows,Columns},OptionName,_?ScalarQ];


Multipanel[
OuterBox:{{_?NumericQ,_?NumericQ},{_?NumericQ,_?NumericQ}},
{Rows_Integer,Columns_Integer},
Opts___?OptionQ
] :=Module[
{
FullOpts=RealizeOptions[Multipanel,Opts],
i,k,
RelativeXPanelSizes,RelativeYPanelSizes,
RelativeXGapSizes,RelativeYGapSizes,
RelativeXMarginSizes,RelativeYMarginSizes,
CanvasXPanelSizes,CanvasYPanelSizes,
CanvasXGapSizes,CanvasYGapSizes,
CanvasXMarginSizes,CanvasYMarginSizes,
x1,x2,y1,y2
},

CheckInScheme[];
CheckOption[XPlotRanges,(RangePattern|VectorPattern[RangePattern]|MatrixPattern[RangePattern]),FullOpts];
CheckOption[YPlotRanges,(RangePattern|VectorPattern[RangePattern]|MatrixPattern[RangePattern]),FullOpts];
CheckOption[XFrameTicks,(TickPattern|VectorPattern[TickPattern]|MatrixPattern[TickPattern]),FullOpts];
CheckOption[YFrameTicks,(TickPattern|VectorPattern[TickPattern]|MatrixPattern[TickPattern]),FullOpts];
CheckOption[XFrameLabels,(_?ScalarQ)|(_?VectorQ)|(_?MatrixQ),FullOpts];
CheckOption[YFrameLabels,(_?ScalarQ)|(_?VectorQ)|(_?MatrixQ),FullOpts];

CheckOption[Margin,_?MarginQ,FullOpts];
CheckOption[XPanelSizes,Automatic|_?NumericQ,{_?NumericQ..},FullOpts];
CheckOption[YPanelSizes,Automatic|_?NumericQ,{_?NumericQ..},FullOpts];
CheckOption[XGapSizes,_?NumericQ,{_?NumericQ..},FullOpts];
CheckOption[YGapSizes,_?NumericQ,{_?NumericQ..},FullOpts];
CheckOption[XMarginSizes,_?NumericQ,{_?NumericQ,_?NumericQ},FullOpts];
CheckOption[YMarginSizes,_?NumericQ,{_?NumericQ,_?NumericQ},FullOpts];
CheckOption[ShowFrameLabels,{True|False,True|False,True|False,True|False},FullOpts]; 
CheckOption[ShowFrameLabelsInterior,{True|False,True|False,True|False,True|False},FullOpts]; 
CheckOption[ShowFrameLabelsExterior,{True|False,True|False,True|False,True|False},FullOpts]; 
CheckOption[ShowTickLabels,{True|False,True|False,True|False,True|False},FullOpts]; 
CheckOption[ShowTickLabelsInterior,{True|False,True|False,True|False,True|False},FullOpts]; 
CheckOption[ShowTickLabelsExterior,{True|False,True|False,True|False,True|False},FullOpts]; 
CheckOption[PanelLetterInset,{_?NumericQ,_?NumericQ},FullOpts];

(* set up indexing *)
LevelScheme`Multipanel`Dimension={Rows,Columns};
LevelScheme`Multipanel`PanelIndices=None;

(* store plot ranges *)
LevelScheme`Multipanel`XPlotRanges=UpgradeMultipanelArray[XPlotRanges/.FullOpts,Horizontal,{Rows,Columns},XPlotRanges,RangePattern];
LevelScheme`Multipanel`YPlotRanges=UpgradeMultipanelArray[YPlotRanges/.FullOpts,Vertical,{Rows,Columns},YPlotRanges,RangePattern];

(* store tick mark information *)
LevelScheme`Multipanel`XFrameTicks=UpgradeMultipanelArray[XFrameTicks/.FullOpts,Horizontal,{Rows,Columns},XFrameTicks,TickPattern];
LevelScheme`Multipanel`YFrameTicks=UpgradeMultipanelArray[YFrameTicks/.FullOpts,Vertical,{Rows,Columns},YFrameTicks,TickPattern];
If[
MatchQ[(XFrameTicks/.FullOpts),TickPattern]&&MatchQ[(XFrameTicks/.FullOpts),{TickPattern..}],
Message[Multipanel::ambigticks,"XFrameTicks"]
];
If[
MatchQ[(YFrameTicks/.FullOpts),TickPattern]&&MatchQ[(YFrameTicks/.FullOpts),{TickPattern..}],
Message[Multipanel::ambigticks,"YFrameTicks"]
];

LevelScheme`Multipanel`ShowTickLabelsExterior=(ShowTickLabelsExterior/.FullOpts);
LevelScheme`Multipanel`ShowTickLabelsInterior=(ShowTickLabelsInterior/.FullOpts);

(* store frame label information *)
LevelScheme`Multipanel`XFrameLabels=UpgradeMultipanelArray[XFrameLabels/.FullOpts,Horizontal,{Rows,Columns},XFrameLabels];
LevelScheme`Multipanel`YFrameLabels=UpgradeMultipanelArray[YFrameLabels/.FullOpts,Vertical,{Rows,Columns},YFrameLabels];
LevelScheme`Multipanel`ShowFrameLabelsExterior=(ShowFrameLabelsExterior/.FullOpts);
LevelScheme`Multipanel`ShowFrameLabelsInterior=(ShowFrameLabelsInterior/.FullOpts);

(* store geometry *)
{{x1,x2},{y1,y2}}=OuterBox+ConvertRegion[AbsoluteCoords,CanvasCoords,D,{{+1,-1},{+1,-1}}*UpgradeMargin[Margin/.FullOpts]];
RelativeXPanelSizes=Switch[
XPanelSizes/.FullOpts,
Automatic,(
If[
!MatchQ[LevelScheme`Multipanel`XPlotRanges,{{{_?NumericQ,_?NumericQ}..}..}],ErrorMessage[Multipanel::autosizes,"XPanelSizes","XPlotRanges"]
];
-Subtract@@@First[LevelScheme`Multipanel`XPlotRanges]
),
_?NumericQ,Table[XPanelSizes/.FullOpts,{Columns}],
{_?NumericQ..},XPanelSizes/.FullOpts
];
If[Length[RelativeXPanelSizes]=!=Columns,
ErrorMessage[Multipanel::num,"X panel sizes"]
];
RelativeYPanelSizes=Switch[
YPanelSizes/.FullOpts,
Automatic,(
If[
!MatchQ[LevelScheme`Multipanel`YPlotRanges,{{{_?NumericQ,_?NumericQ}..}..}],ErrorMessage[Multipanel::autosizes,"YPanelSizes","YPlotRanges"]
];
-Subtract@@@First[Transpose[LevelScheme`Multipanel`YPlotRanges]]
),
_?NumericQ,Table[YPanelSizes/.FullOpts,{Rows}],
{_?NumericQ..},YPanelSizes/.FullOpts
];
If[Length[RelativeYPanelSizes]=!=Rows,
ErrorMessage[Multipanel::num,"Y panel sizes"]
];
RelativeXGapSizes=Switch[
XGapSizes/.FullOpts,
_?NumericQ,Table[XGapSizes/.FullOpts,{Columns-1}],
{_?NumericQ..},XGapSizes/.FullOpts
];
If[Length[RelativeXGapSizes]=!=(Columns-1),
ErrorMessage[Multipanel::num,"X panel gaps"]
];
RelativeYGapSizes=Switch[
YGapSizes/.FullOpts,
_?NumericQ,Table[YGapSizes/.FullOpts,{Rows-1}],
{_?NumericQ..},YGapSizes/.FullOpts
];
If[Length[RelativeYGapSizes]=!=(Rows-1),
ErrorMessage[Multipanel::num,"Y panel gaps"]
];
RelativeXMarginSizes=Switch[
XMarginSizes/.FullOpts,
_?NumericQ,Table[XMarginSizes/.FullOpts,{2}],
{_?NumericQ,_?NumericQ},XMarginSizes/.FullOpts
];
RelativeYMarginSizes=Switch[
YMarginSizes/.FullOpts,
_?NumericQ,Table[YMarginSizes/.FullOpts,{2}],
{_?NumericQ,_?NumericQ},YMarginSizes/.FullOpts
];
LevelScheme`Multipanel`CanvasXUnit=(x2-x1)/(Plus@@RelativeXPanelSizes+Plus@@RelativeXGapSizes+Plus@@RelativeXMarginSizes);
CanvasXPanelSizes=RelativeXPanelSizes*LevelScheme`Multipanel`CanvasXUnit;
CanvasXGapSizes=RelativeXGapSizes*LevelScheme`Multipanel`CanvasXUnit;
CanvasXMarginSizes=RelativeXMarginSizes*LevelScheme`Multipanel`CanvasXUnit;
LevelScheme`Multipanel`CanvasYUnit=(y2-y1)/(Plus@@RelativeYPanelSizes+Plus@@RelativeYGapSizes+Plus@@RelativeYMarginSizes);
CanvasYPanelSizes=RelativeYPanelSizes*LevelScheme`Multipanel`CanvasYUnit;
CanvasYGapSizes=RelativeYGapSizes*LevelScheme`Multipanel`CanvasYUnit;
CanvasYMarginSizes=RelativeYMarginSizes*LevelScheme`Multipanel`CanvasYUnit;
LevelScheme`Multipanel`XRegionRangeList=Table[
x1+CanvasXMarginSizes[[1]]+Sum[CanvasXPanelSizes[[k]]+CanvasXGapSizes[[k]],{k,1,i-1}]+{0,CanvasXPanelSizes[[i]]},
{i,1,Columns}
];
LevelScheme`Multipanel`YRegionRangeList=Table[
y2-CanvasYMarginSizes[[1]]-Sum[CanvasYPanelSizes[[k]]+CanvasYGapSizes[[k]],{k,1,i-1}]+{-CanvasYPanelSizes[[i]],0},
{i,1,Rows}
];



(* store frozen copy of Panel formatting option defaults *)
LevelScheme`Multipanel`PanelOptions={LegacyFilterOptions[FigurePanel,FullOpts]};

Null

];


BasicFigurePanel[Caller_Symbol,RegionRange:{{_?NumericQ,_?NumericQ},{_?NumericQ,_?NumericQ}},FullOpts_List]:=Module[
{
ExpandedPlotRange,XYPlotRange,UsedPlotRange,DeducedFrameLabel,DeducedFrameLabelOptions,DeducedFrameTicks,AxisIndex,PanelLetterPosn
},
CheckInScheme[];

CheckOption[PlotRange,Automatic|{Automatic|{_?NumericQ,_?NumericQ},Automatic|{_?NumericQ,_?NumericQ}},FullOpts];
CheckOption[Background,None|ColorDirectivePattern,FullOpts];
CheckOption[BackgroundOpacity,_?NumericQ,FullOpts];
CheckOption[FrameLabel,None|Automatic|(L_List/;(Length[L]<=4)),FullOpts];
CheckOption[ShowFrameLabels,{True|False,True|False,True|False,True|False},FullOpts];CheckOption[ShowEdge,{True|False,True|False,True|False,True|False},FullOpts];
CheckOption[ShowTicks,{True|False,True|False,True|False,True|False},FullOpts];
CheckOption[ShowTickLabels,{True|False,True|False,True|False,True|False},FullOpts];
CheckOption[TickNudge,(L:{(_?NumericQ|{_?NumericQ,_?NumericQ})...}/;(Length[L]==4)),FullOpts];
CheckOption[ExtendRange,_?NumericQ|{_?NumericQ,_?NumericQ}|{{_?NumericQ,_?NumericQ},{_?NumericQ,_?NumericQ}},FullOpts];


(* calculate plot range *)
(* (1) expand PlotRange value Automatic to {Automatic,Automatic}; (2) for each coordinate, use explicit range if given in PlotRange, or for Automatic default to separate XPlotRange and YPlotRange; (3) for XPlotRange and YPlotRange, use explicit ranges if given or else for Automatic default to canvas coordinate range covered by panel (dubious value) *)
ExpandedPlotRange=GetAutoOption[PlotRange,{Automatic,Automatic},FullOpts];
XYPlotRange=MapThread[
(Replace[#1,Automatic->#2]&),
{ExpandedPlotRange,{XPlotRange,YPlotRange}/.FullOpts}
];
UsedPlotRange=ExtendRegion[
MapThread[
(Replace[#1,Automatic->#2]&),
{XYPlotRange,RegionRange}
],
(ExtendRange/.FullOpts)
];

(* set up global properties for panel *)
$Background=Background/.FullOpts;
SetRegion[RegionRange,UsedPlotRange];

(* obtain frame labels, defaulting to LabX option values *)
(* construct explicit list of labels *)
DeducedFrameLabel=Switch[
(FrameLabel/.FullOpts),
Automatic,
{LabB,LabL,LabT,LabR}/.FullOpts,
None,
{None,None,None,None},
_List,
AugmentList[4,(FrameLabel/.FullOpts),None]
];
(* remove labels except on sides where allowed *)
DeducedFrameLabel=MapThread[
(If[#2,#1,None]&),
{DeducedFrameLabel,ShowFrameLabels/.FullOpts}
];
(* clothe frame labels as LabX option rules *)
DeducedFrameLabelOptions=MapThread[Rule,{{LabB,LabL,LabT,LabR},DeducedFrameLabel}];

(* process frame tick specification *)
(* augment specification so that it is a list of lists*)
DeducedFrameTicks=GetAutoOption[FrameTicks,{Automatic,Automatic,None,None},FullOpts];
DeducedFrameTicks=AugmentAxisTickOptions[4,DeducedFrameTicks];
(* generate any automatic ticks with LinTicks, with labels on for the bottom and left and off for the top and right *)
DeducedFrameTicks=MapThread[
(Replace[#1,Automatic:>LinTicks[Sequence@@#2,ShowLabels->#3]]&),
{
DeducedFrameTicks,
{UsedPlotRange[[1]],UsedPlotRange[[2]],UsedPlotRange[[1]],UsedPlotRange[[2]]},
{True,True,False,False}
}
];
(* augment any under-specified ticks *)
DeducedFrameTicks=(AugmentTicks[{0.01,0},{},#]&)/@DeducedFrameTicks;
(* convert to canvas coordinates *)
DeducedFrameTicks=MapThread[
(TransformTicks[#1,#2,LimitTickRange[#3,#4]]&),
{
{XCOfXU,YCOfYU,XCOfXU,YCOfYU},
{DYCTick,DXCTick,DYCTick,DXCTick},
{UsedPlotRange[[1]],UsedPlotRange[[2]],UsedPlotRange[[1]],UsedPlotRange[[2]]},
DeducedFrameTicks
}
];
(* remove labels except on sides where allowed *)
DeducedFrameTicks=MapThread[
(If[#2,#1,StripTickLabels[#1]]&),
{DeducedFrameTicks,ShowTickLabels/.FullOpts}
];
(* remove ticks except on sides where allowed *)
DeducedFrameTicks=MapThread[
(If[#2,#1,{}]&),
{DeducedFrameTicks,(ShowTicks/.FullOpts)}
];

(* construct artwork *)
{
(* fill *)
If[
$Background=!=None,
MakeFill[
{Rectangle@@Transpose[RegionRange]},
Color->(Background/.FullOpts),Opacity->(BackgroundOpacity/.FullOpts),
ShowFill->True,FillColor->Automatic,FillOpacity->Automatic,ClipToRectangle->False,
Layer->GetAutoOption[Layer,$SchemeBackgroundLayer,FullOpts],
FullOpts
]
],

(* edges *)
(* axis options are as in FullOpts, except LabX is overriden by FrameLabel, TickNudge is an edge-by-edge list, and the Ticks are given for the whole frame *)
Table[
If[(Frame/.FullOpts)&&(ShowEdge/.FullOpts)[[AxisIndex]],
BasicAxis[Caller,
RegionRange,
AxisIndex,
(ShowEdge/.FullOpts)[[AxisIndex]],
False,
DeducedFrameTicks[[AxisIndex]],
Flatten[{DeducedFrameLabelOptions,TickNudge->(TickNudge/.FullOpts)[[AxisIndex]],FullOpts}]
]
],
{AxisIndex,1,4}
],

(* panel letter *)
PanelLetterPosn=PCOfPS[(PanelLetterCorner/.FullOpts)/.{-1->0}]
+(-1)*(PanelLetterCorner/.FullOpts)*DPCOfPA@(PanelLetterInset/.FullOpts);
MakeText[(PanelLetter/.FullOpts), PanelLetterPosn,0,
ShowText->(ShowPanelLetter/.FullOpts),
Offset->GetAutoOption[PanelLetterOffset,{0,0},FullOpts],
Nudge->(PanelLetterNudge/.FullOpts),
Orientation->(PanelLetterOrientation/.FullOpts),
Background->(PanelLetterBackground/.FullOpts),
FontFamily->GetAutoOption[PanelLetterFontFamily,FontFamily/.FullOpts,FullOpts],
FontSize->GetAutoOption[PanelLetterFontSize,FontSize/.FullOpts,FullOpts],
FontWeight->GetAutoOption[PanelLetterFontWeight,FontWeight/.FullOpts,FullOpts],
FontSlant->GetAutoOption[PanelLetterFontSlant,FontSlant/.FullOpts,FullOpts],
FontTracking->GetAutoOption[PanelLetterFontTracking,FontTracking/.FullOpts,FullOpts],
FontColor->GetAutoOption[PanelLetterFontColor,FontColor/.FullOpts,FullOpts],
FontOpacity->GetAutoOption[PanelLetterFontOpacity,FontOpacity/.FullOpts,FullOpts],
FullOpts 
]

}
];
FigurePanel[RegionRange:{{_?NumericQ,_?NumericQ},{_?NumericQ,_?NumericQ}},Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[FigurePanel,Opts],
AugmentedOpts
},
AugmentedOpts=Flatten[{ClipToRectangle->False,FullOpts}];  (* provide ClipToRectangle value *)
BasicFigurePanel[FigurePanel,RegionRange,AugmentedOpts]
];
ScaledFigurePanel[ScaledRange:{{x1s_?NumericQ,x2s_?NumericQ},{y1s_?NumericQ,y2s_?NumericQ}},Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[ScaledFigurePanel,Opts],
AugmentedOpts
},
AugmentedOpts=Flatten[{ClipToRectangle->False,FullOpts}];  (* provide ClipToRectangle value *)
BasicFigurePanel[ScaledFigurePanel,{XCOfXS/@{x1s,x2s},YCOfYS/@{y1s,y2s}},AugmentedOpts]
];


FigurePanel[PanelIndices:{Row_Integer,Column_Integer},Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[FigurePanel,{Opts,LevelScheme`Multipanel`PanelOptions}],
DeducedFullOpts,
OptPanelShift,OptPanelAdjustments,
RegionRange,MultipanelPlotRange,ExpandedPlotRange,XYPlotRange,DeducedPlotRange,
DeducedFrameLabel,DeducedShowFrameLabels,
DeducedFrameTicks,DeducedShowTickLabels,
DeducedPanelLetter,
DeducedOptions,
AugmentedOpts,
ExteriorMask
},

CheckInScheme[];
If[
!ValueQ[LevelScheme`Multipanel`Dimension],
ErrorMessage[FigurePanel::undefined]
];
If[
!TrueQ[InRegion[{1,1},LevelScheme`Multipanel`Dimension,PanelIndices]],
ErrorMessage[FigurePanel::badij,PanelIndices]
];
CheckOption[PlotRange,Automatic|{{_?NumericQ,_?NumericQ},{_?NumericQ,_?NumericQ}},FullOpts];
CheckOption[PanelShift,None|{_?NumericQ,_?NumericQ},FullOpts];
CheckOption[PanelAdjustments,None|{{_?NumericQ,_?NumericQ},{_?NumericQ,_?NumericQ}},FullOpts];

LevelScheme`Multipanel`PanelIndices=PanelIndices;

(* calculate geometry *)
OptPanelShift=If[(PanelShift/.FullOpts)===None,{0,0},(PanelShift/.FullOpts)];
OptPanelAdjustments=If[(PanelAdjustments/.FullOpts)===None,{{0,0},{0,0}},(PanelAdjustments/.FullOpts)];
RegionRange={
LevelScheme`Multipanel`XRegionRangeList[[Column]]+OptPanelShift[[1]]*LevelScheme`Multipanel`CanvasXUnit+OptPanelAdjustments[[1]]*LevelScheme`Multipanel`CanvasXUnit,
LevelScheme`Multipanel`YRegionRangeList[[Row]]+OptPanelShift[[2]]*LevelScheme`Multipanel`CanvasYUnit+OptPanelAdjustments[[2]]*LevelScheme`Multipanel`CanvasYUnit
};

(* calculate plot range *)
(* (1) expand PlotRange value Automatic to {Automatic,Automatic}; (2) for each coordinate, use explicit range if given in PlotRange, or for Automatic default to separate XPlotRange and YPlotRange; (3) for XPlotRange and YPlotRange, use explicit ranges if given or else for Automatic default to range for this row and column specified to Multipanel; (4) note that if Multipanel range is in turn Automatic, BasicPanel will later extend this range if necessary and convert this to the range of canvas coordinates covered by the panel *)
MultipanelPlotRange={LevelScheme`Multipanel`XPlotRanges[[Row,Column]],LevelScheme`Multipanel`YPlotRanges[[Row,Column]]};
ExpandedPlotRange=GetAutoOption[PlotRange,{Automatic,Automatic},FullOpts];
XYPlotRange=MapThread[
(Replace[#1,Automatic->#2]&),
{ExpandedPlotRange,{XPlotRange,YPlotRange}/.FullOpts}
];
DeducedPlotRange=MapThread[
(Replace[#1,Automatic->#2]&),
{XYPlotRange,MultipanelPlotRange}
];

(* exterior mask for edges of current panel *)
ExteriorMask={
Row==LevelScheme`Multipanel`Dimension[[1]],
Column==1,
Row==1,
Column==LevelScheme`Multipanel`Dimension[[2]]
};

(* deduce labels *)
DeducedFrameLabel={LevelScheme`Multipanel`XFrameLabels[[Row,Column]],LevelScheme`Multipanel`YFrameLabels[[Row,Column]],None,None};
DeducedShowFrameLabels=ListableAnd[
(ShowFrameLabels/.LevelScheme`Multipanel`PanelOptions),
ListableOr[
ListableAnd[ExteriorMask,LevelScheme`Multipanel`ShowFrameLabelsExterior],
ListableAnd[ListableNot[ExteriorMask],LevelScheme`Multipanel`ShowFrameLabelsInterior]
]
];

(* deduce ticks *)
DeducedFrameTicks={LevelScheme`Multipanel`XFrameTicks[[Row,Column]],LevelScheme`Multipanel`YFrameTicks[[Row,Column]],LevelScheme`Multipanel`XFrameTicks[[Row,Column]],LevelScheme`Multipanel`YFrameTicks[[Row,Column]]};
(* deduce tick label sides *)
(* condition for tick labels to be shown is (outer edge) AND (edge allowed by ShowTickLabels option at time of Multipanel invocation) *)
DeducedShowTickLabels=ListableAnd[
(ShowTickLabels/.LevelScheme`Multipanel`PanelOptions),
ListableOr[
ListableAnd[ExteriorMask,LevelScheme`Multipanel`ShowTickLabelsExterior],
ListableAnd[ListableNot[ExteriorMask],LevelScheme`Multipanel`ShowTickLabelsInterior]
]
];

(* deduce panel label *)
DeducedPanelLetter=PanelLetter[LegacyFilterOptions[PanelLetter,FullOpts]];

(* combine deduced options *)
DeducedOptions={
PlotRange->DeducedPlotRange,
FrameLabel->Automatic, (* for easier user override with LabX *)
LabB->DeducedFrameLabel[[1]],LabL->DeducedFrameLabel[[2]],LabT->DeducedFrameLabel[[3]],LabR->DeducedFrameLabel[[4]],
ShowFrameLabels->DeducedShowFrameLabels,
FrameTicks->DeducedFrameTicks,ShowTickLabels->DeducedShowTickLabels,
PanelLetter->DeducedPanelLetter
};
DeducedFullOpts=RealizeOptions[FigurePanel,{Opts,DeducedOptions,LevelScheme`Multipanel`PanelOptions}];

AugmentedOpts=Flatten[{ClipToRectangle->False,DeducedFullOpts}];  (* provide ClipToRectangle value *)
BasicFigurePanel[FigurePanel,RegionRange,AugmentedOpts]

];


PanelLetter[Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[PanelLetter,Opts],
StartLetterCode,Letter,
i,j
},
CheckInScheme[];
CheckOption[Order,Horizontal|Vertical,FullOpts];
If[
LevelScheme`Multipanel`PanelIndices===None,
ErrorMessage[PanelLetter::nopanel]
];
StartLetterCode=ToCharacterCode[First/.FullOpts];

{i,j}=LevelScheme`Multipanel`PanelIndices;
Letter=Switch[
Order/.FullOpts,
Horizontal,FromCharacterCode[StartLetterCode+LevelScheme`Multipanel`Dimension[[2]]*(i-1)+(j-1)],
Vertical,FromCharacterCode[StartLetterCode+(i-1)+LevelScheme`Multipanel`Dimension[[1]]*(j-1)]
];
(Format/.FullOpts)[[1]]<>Letter<>(Format/.FullOpts)[[2]]
];


AttachIndex[DataValues_List,Opts___?OptionQ]:=Module[
{FullOpts=RealizeOptions[AttachIndex,Opts],
s,x0},

CheckOption[First,_?NumericQ,FullOpts];
CheckOption[ScaleFactor,_?NumericQ,FullOpts];
CheckOption[Range,{_?NumericQ,_?NumericQ}|Automatic,FullOpts];

Switch[Range/.FullOpts,
Automatic,
s=(ScaleFactor/.FullOpts);
x0=(First/.FullOpts),
{_?NumericQ,_?NumericQ},
s=(Subtract@@Reverse[Range/.FullOpts])/(Length[DataValues]-1);
x0=First[Range/.FullOpts]
];

MapIndexed[{s*(First[#2]-1)+x0,#1}&,DataValues]
];


DataValueQ[x_]:=MatchQ[x,((_?RealNumericQ)|None)|ErrorValue[((_?RealNumericQ)|None),(_?RealNumericQ)|None|{((_?RealNumericQ)|None),((_?RealNumericQ)|None)}]];
DataValueNoneQ[x_]:=MatchQ[x,(None)|ErrorValue[None,(_?RealNumericQ)|None|{((_?RealNumericQ)|None),((_?RealNumericQ)|None)}]];


DataPointQ[x_]:=MatchQ[x,{_?DataValueQ,_?DataValueQ}];
DataPointNoneQ[x_]:=MatchQ[x,{_?DataValueNoneQ,_?DataValueQ}|{_?DataValueQ,_?DataValueNoneQ}];


DataSetQ[x_]:=MatchQ[x,{(_?DataPointQ)...}];


SelectData[Test_,Opts___?OptionQ][Data_?DataSetQ]:=Replace[Data,{_?NumericQ,_?NumericQ}?(Composition[Not,Test])->{None,None},{1}];
ExcludeData[Test_,Opts___?OptionQ][Data_?DataSetQ]:=Replace[Data,{_?NumericQ,_?NumericQ}?Test->{None,None},{1}];
TransformData[f_,Opts___?OptionQ][Data_?DataSetQ]:=Replace[Data,x:{_?NumericQ,_?NumericQ}:>f[x],{1}];
DownsampleData[n_Integer,Opts___?OptionQ][Data_?DataSetQ]:=Module[{i=0},Select[Data,(Mod[i++,n]==0&)]];


XRange[x1_?RealNumericQ,x2_?RealNumericQ]:=(InRange[{x1,x2},#[[1]]]&);
YRange[y1_?RealNumericQ,y2_?RealNumericQ]:=(InRange[{y1,y2},#[[2]]]&);
InPlotRegion:=(InRegion[$RegionRange,PCOfPU[#]]&);
LimitX[x1_?RealNumericQ,x2_?RealNumericQ]:=(Switch[#,_?(XRange[x1,x2]),#,_?(XRange[-Infinity,x1]),{x1,#[[2]]},_?(XRange[x2,+Infinity]),{x2,#[[2]]},_,Message[LimitX::badvalue,#]]&);
LimitY[y1_?RealNumericQ,y2_?RealNumericQ]:=(Switch[#,_?(YRange[y1,y2]),#,_?(YRange[-Infinity,y1]),{#[[1]],y1},_?(YRange[y2,+Infinity]),{#[[1]],y2},_,Message[LimitY::badvalue,#]]&);


DataLineShape["Straight",n_][Points_List]:=Points;
DataLineShape["Step",n_][Points_List]:=Join[
{First[Points]},
Flatten[
Table[
{
{(First[Points[[i]]]+First[Points[[i+1]]])/2,Last[Points[[i]]]},{(First[Points[[i]]]+First[Points[[i+1]]])/2,Last[Points[[i+1]]]}
},
{i,1,Length[Points]-1}
],
1
],
{Last[Points]}
];
DataLineShape["StepAnchored",n_][Points_List]:=Join[
{
{(3/2*First[Points[[1]]]-1/2*First[Points[[2]]]),YCOfYU@0},
{(3/2*First[Points[[1]]]-1/2*First[Points[[2]]]),Last[Points[[1]]]}
},
Flatten[
Table[
{
{(First[Points[[i]]]+First[Points[[i+1]]])/2,Last[Points[[i]]]},
{(First[Points[[i]]]+First[Points[[i+1]]])/2,Last[Points[[i+1]]]}
},
{i,1,Length[Points]-1}
],
1
],
{
{(3/2*First[Points[[-1]]]-1/2*First[Points[[-2]]]),Last[Points[[-1]]]},
{(3/2*First[Points[[-1]]]-1/2*First[Points[[-2]]]),YCOfYU@0}
}
];
DataLineShape["Histogram",n_][Points_List]:=Join[
{
{(3/2*First[Points[[1]]]-1/2*First[Points[[2]]]),YCOfYU@0},
{(3/2*First[Points[[1]]]-1/2*First[Points[[2]]]),Last[Points[[1]]]}
},
Flatten[
Table[
{
{(First[Points[[i]]]+First[Points[[i+1]]])/2,Last[Points[[i]]]},
{(First[Points[[i]]]+First[Points[[i+1]]])/2,YCOfYU@0},
{(First[Points[[i]]]+First[Points[[i+1]]])/2,Last[Points[[i+1]]]}
},
{i,1,Length[Points]-1}
],
1
],
{
{(3/2*First[Points[[-1]]]-1/2*First[Points[[-2]]]),Last[Points[[-1]]]},
{(3/2*First[Points[[-1]]]-1/2*First[Points[[-2]]]),YCOfYU@0}
}
];


DataSymbolShape["Circle",n_]:=Table[{Cos[2*Pi*i/n],Sin[2*Pi*i/n]},{i,1,n}];


DataSymbolShape["UpTriangle",n_]:=1.2*{{0.,1.},{-0.8660254037844386,-0.5},{0.8660254037844386,-0.4999999999999999}};
DataSymbolShape["LeftTriangle",n_]:=1.2*{{-1.,0.},{0.5,-0.8660254037844386},{0.4999999999999999,0.8660254037844386}};
DataSymbolShape["DownTriangle",n_]:=1.2*{{0.,-1.},{0.8660254037844386,0.5},{-0.8660254037844386,0.4999999999999999}};
DataSymbolShape["RightTriangle",n_]:=1.2*{{1.,0.},{-0.5,0.8660254037844386},{-0.4999999999999999,-0.8660254037844386}};


DataSymbolShape["Square",n_]:=1.2*{{-0.7071067811865476,0.7071067811865476},{-0.7071067811865476,-0.7071067811865476},{0.7071067811865476,-0.7071067811865476},{0.7071067811865476,0.7071067811865476}};
DataSymbolShape["Diamond",n_]:=1.2*{{0.,1.},{-1.,0.},{0.,-1.},{1.,0.}};


DataSymbolVertices[SymbolShape_,SymbolSize_?NumericQ,PlotPoints_Integer][P:{_?NumericQ,_?NumericQ}]:=Module[
{BasicShape},
BasicShape=DPCOfPA/@N[(SymbolSize/2)*DataSymbolShape[SymbolShape,PlotPoints]];
If[!MatchQ[BasicShape,{{_?NumericQ,_?NumericQ}..}],ErrorMessage[SchemePoints::badsymbol,SymbolShape]];
(P+#)&/@BasicShape
];


ErrorBarPrimatives[{x_,y_},{dx_,dy_},{Capx_,Capy_}]:={
Line[{{x,y},{x,y}+{dx,dy}}],
Line[{{x,y}+{dx,dy}-DPCOfPA@{Capx,Capy},{x,y}+{dx,dy}+DPCOfPA@{Capx,Capy}}]
};


NoneFreeQ[x_]:=!DataPointNoneQ[x];
NoneFreeQ[x_,y_]:=NoneFreeQ[x]&&NoneFreeQ[y];
PartitionDataForLine[Data_?DataSetQ]:=Cases[Split[Data,NoneFreeQ],x:{__?NoneFreeQ}/;(Length[x]>=2)];


ApplyOrNone[f_][x_?NumericQ]:=f[x];
ApplyOrNone[f_][None]:=None;


RecurseData[Data_?DataSetQ]:=ProcessDataSetGroup[{Data}];
RecurseData[Data:{(_?DataSetQ)...}]:=ProcessDataSetGroup[Data];
RecurseData[Data:DataHold[x_]]:=(x);
RecurseData[Data_List]:=BlockOptions[
{DataLine,DataSymbol,DataTransformation},RecurseData/@Data
];
RecurseData[Data:Null]:={};  (* to accept extra commas silently *)
RecurseData[Data_]:=Message[DataPlot::baddata,Data];


ProcessDataSetGroup[Data:{(_?DataSetQ)...}]:=Module[
{
DataLineOpts,DataSymbolOpts,DataTransformationOpts,
FilteredData,
Segments,
Points,PointCenters,
BasicShape,i,Point,PointVertices,CentralPoints,ExpandedErrorPoints,
LineArt,SymbolOutlineArt,SymbolFillArt,ErrorBarArt
},

If[!$ProcessDataSets,Return[{}]];

(* Generate plot options *)

DataTransformationOpts=RealizeOptions[DataTransformation];
DataLineOpts=RealizeOptions[DataLine];
DataSymbolOpts=RealizeOptions[DataSymbol];


(* Validate plot options *)

CheckOption[DataFilters,None|(_List),DataTransformationOpts];
CheckOption[Show,True|False,DataLineOpts];
CheckOption[Show,True|False,DataSymbolOpts];
CheckOption[SymbolSize,(_?NumericQ)?Positive,DataSymbolOpts];
CheckOption[PlotPoints,_Integer?Positive,DataSymbolOpts];

(* Construct data point lists *)

FilteredData=Switch[
DataFilters/.DataTransformationOpts,
None|{},Data,
_List,(Composition@@Reverse[DataFilters/.DataTransformationOpts])/@Data
];
Points=Select[Flatten[FilteredData,1],NoneFreeQ];
Segments=Map[PCOfPU,Flatten[PartitionDataForLine/@(FilteredData/.{ErrorValue[x_,_]:>x}),1],{2}];
PointCenters=Map[PCOfPU,(Points/.{ErrorValue[x_,_]:>x})];
ExpandedErrorPoints=Replace[
Points,
{
{x_?NumericQ,y_}:>{ErrorValue[x,{None,None}],y},
{ErrorValue[x_,None],y_}:>{ErrorValue[x,{None,None}],y},
{ErrorValue[x_,dx_?NumericQ],y_}:>{ErrorValue[x,{-dx,dx}],y}
},
{1}
];
ExpandedErrorPoints=Replace[
ExpandedErrorPoints,
{
{x_,y_?NumericQ}:>{x,ErrorValue[y,{None,None}]},
{x_,ErrorValue[y_,None]}:>{x,ErrorValue[y,{None,None}]},
{x_,ErrorValue[y_,dy_?NumericQ]}:>{x,ErrorValue[y,{-dy,dy}]}
},
{1}
];
ExpandedErrorPoints=Replace[
ExpandedErrorPoints,
{
{ErrorValue[x_,{dxm_,dxp_}],ErrorValue[y_,{dym_,dyp_}]}:>
{ErrorValue[ApplyOrNone[XCOfXU]@x,ApplyOrNone[DXCOfXU]/@{dxm,dxp}],ErrorValue[ApplyOrNone[YCOfYU]@y,ApplyOrNone[DYCOfYU]/@{dym,dyp}]}
},
{1}
];

(* Construct lines *)

LineArt=If[
(Show/.DataLineOpts),
Line/@DataLineShape[LineShape/.DataLineOpts,PlotPoints/.DataLineOpts]/@Segments,
{}
];

(* Construct symbols *)

If[
(Show/.DataSymbolOpts),
PointVertices=DataSymbolVertices[SymbolShape/.DataSymbolOpts,SymbolSize/.DataSymbolOpts,PlotPoints/.DataSymbolOpts]/@PointCenters
];

SymbolOutlineArt=If[
(Show/.DataSymbolOpts),
(Line[Append[#,First[#]]]&)/@PointVertices,
{}
];
SymbolFillArt=If[
(Show/.DataSymbolOpts),
Polygon/@PointVertices,
{}
];

(* Construct error bars *)
ErrorBarArt=If[
(Show/.DataSymbolOpts),

Join[
Cases[
ExpandedErrorPoints,
{ErrorValue[x_,{dxm_?NumericQ,dxp_}],ErrorValue[y_,{dym_,dyp_}]}:>ErrorBarPrimatives[{x,y},{dxm,0},{0,(SymbolSize/.DataSymbolOpts)/2}]
],
Cases[
ExpandedErrorPoints,
{ErrorValue[x_,{dxm_,dxp_?NumericQ}],ErrorValue[y_,{dym_,dyp_}]}:>ErrorBarPrimatives[{x,y},{dxm,0},{0,(SymbolSize/.DataSymbolOpts)/2}]
],
Cases[
ExpandedErrorPoints,
{ErrorValue[x_,{dxm_,dxp_}],ErrorValue[y_,{dym_?NumericQ,dyp_}]}:>ErrorBarPrimatives[{x,y},{0,dym},{(SymbolSize/.DataSymbolOpts)/2,0}]
],
Cases[
ExpandedErrorPoints,
{ErrorValue[x_,{dxm_,dxp_}],ErrorValue[y_,{dym_,dyp_?NumericQ}]}:>ErrorBarPrimatives[{x,y},{0,dyp},{(SymbolSize/.DataSymbolOpts)/2,0}]
]
],
{}
];

(* Save dataset info *)
If[$DataTag=!=Dummy,
LevelScheme`Data`DataTransformationOpts[$DataTag]=DataTransformationOpts;
LevelScheme`Data`DataLineOpts[$DataTag]=DataLineOpts;
LevelScheme`Data`DataSymbolOpts[$DataTag]=DataSymbolOpts;
LevelScheme`Data`DataCanvasPoints[$DataTag]=PCOfPU/@Points
];

(* Clear any data set name *)
$DataTag=Dummy;

(* Draw artwork *)

{

MakeOutline[
LineArt,
DataLineOpts
],

(* Error bars -- behind fill *)
MakeOutline[{ErrorBarArt},DataSymbolOpts],

(* Fill *)

MakeFill[{SymbolFillArt},DataSymbolOpts],

(* Outline *)

MakeOutline[{SymbolOutlineArt},DataSymbolOpts]

}

];


DataHeldFunctions={SetOptions,DataTag,SaveDataStyle,SetDataStyle,DataLabel};
DataHeldPattern=Alternatives@@Blank/@DataHeldFunctions;
SetAttributes[DataHold,HoldFirst];


SetAttributes[DataPlot,HoldFirst];
DataPlot[Data_,Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[DataPlot,Opts],
Item,
LineOpts={},
SymbolOpts={},
LineEnabled=False,
SymbolEnabled=False,
SafeData
},

CheckInScheme[];
CheckOption[ShowData,True|False,FullOpts];
$DataTag=Dummy;

$ProcessDataSets=(ShowData/.FullOpts);
Block[
Evaluate[DataHeldFunctions],
SafeData=ReplaceAll[Data,{s:DataHeldPattern:>DataHold[s]}];
If[Debug/.FullOpts,Print[SafeData]]
];
RecurseData[SafeData]

];


DataLabel[ID_,Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[DataLabel,Opts]
},

CheckInScheme[];
CheckDataSet[ID];

BasicLineAnnotations[LevelScheme`Data`DataCanvasPoints[ID],FullOpts]

];


DataTag[ID_,Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[DataTag,Opts]
},
CheckInScheme[];
CheckValue[ID,IDExpr_?LevelIdentifierQ,"a data set identifier symbol (cannot be list or number)"];
$DataTag=ID;

(* store tentative style information in case no plot later made *)
LevelScheme`Data`DataTransformationOpts[$DataTag]=RealizeOptions[DataTransformation];
LevelScheme`Data`DataLineOpts[$DataTag]=RealizeOptions[DataLine];
LevelScheme`Data`DataSymbolOpts[$DataTag]=RealizeOptions[DataSymbol];
LevelScheme`Data`DataCanvasPoints[$DataTag]={};
LevelScheme`Data`DataTagDefined[$DataTag]=True;
];


SaveDataStyle[ID_,Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[SaveDataStyle,Opts],
DataStyle
},
CheckInScheme[];
CheckValue[ID,IDExpr_?LevelIdentifierQ,"a data set identifier symbol (cannot be list or number)"];
DataStyle=ID;

LevelScheme`Data`DataTransformationOpts[DataStyle]=RealizeOptions[DataTransformation];
LevelScheme`Data`DataLineOpts[DataStyle]=RealizeOptions[DataLine];
LevelScheme`Data`DataSymbolOpts[DataStyle]=RealizeOptions[DataSymbol];
LevelScheme`Data`DataCanvasPoints[DataStyle]={};
LevelScheme`Data`DataTagDefined[DataStyle]=True;
];


SetDataStyle[ID_,Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[SetDataStyle,Opts]
},
CheckInScheme[];
CheckDataSet[ID];
If[
Debug/.FullOpts,
Print["Restoring style: ",ID];
Print[LevelScheme`Data`DataTransformationOpts[ID]];
Print[LevelScheme`Data`DataLineOpts[ID]];
Print[LevelScheme`Data`DataSymbolOpts[ID]]
];
BlockUnprotect[
{DataTransformation,DataLine,DataSymbol},
Options[DataTransformation]=LevelScheme`Data`DataTransformationOpts[ID];
Options[DataLine]=LevelScheme`Data`DataLineOpts[ID];
Options[DataSymbol]=LevelScheme`Data`DataSymbolOpts[ID]
];
];


DataLegend[PS:{_?NumericQ,_?NumericQ},DataSetInfo:{{_,_}...},Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[DataLegend,Opts],
P0,Pi,DPY,DPLeft,DPCenter,DPRight,DPText,
DataSetID,DataSetText,LineVertices,
DataLineOpts,DataSymbolOpts,SymbolVertices,
i
},

P0=PCOfPS[PS];
DPY={0,-DYCOfYA[FontSize/.FullOpts]};
DPLeft={0,0};
DPSymbol={DXCOfXA[Length/.FullOpts],0};
DPRight={2*DXCOfXA[Length/.FullOpts],0};
DPText={2*DXCOfXA[Length/.FullOpts]+DXCOfXA[Gap/.FullOpts],0};

TableForEach[
{

Pi=P0+1/2*DPY+(i-1)*(LineSpacing/.FullOpts)*DPY;

CheckDataSet[DataSetID];
DataLineOpts=LevelScheme`Data`DataLineOpts[DataSetID];
LineVertices={Pi+DPLeft,Pi+DPRight};
MakeOutline[{Line[LineVertices]},DataLineOpts],

DataSymbolOpts=LevelScheme`Data`DataSymbolOpts[DataSetID];
SymbolVertices=DataSymbolVertices[
SymbolShape/.DataSymbolOpts,
SymbolSize/.DataSymbolOpts,
PlotPoints/.DataSymbolOpts
][Pi+DPSymbol];
MakeOutline[{(Line[Append[#,First[#]]]&)@SymbolVertices},DataSymbolOpts],
MakeFill[{Polygon@SymbolVertices},DataSymbolOpts],

MakeText[DataSetText,Pi+DPText,0,Offset->{-1,0},FullOpts]

},
{{DataSetID,DataSetText},i,DataSetInfo}
]
];


SetAttributes[SchemeIfDef,HoldRest];  (* HoldRest to avoid side effects of evaluating Objects sequence *)
SchemeIfDef[Flag_,Objects___]:=Sequence@@If[MemberQ[$SchemeFlags,Flag],{Objects},{}];
SetAttributes[SchemeIfNDef,HoldRest];  (* HoldRest to avoid side effects of evaluating Objects sequence *)
SchemeIfNDef[Flag_,Objects___]:=Sequence@@If[!MemberQ[$SchemeFlags,Flag],{Objects},{}];


GetLayer[SchemeGraphics[_,_,LayerID_]]:=LayerID;
SchemeGraphicsOrderedQ=Function[{Obj1,Obj2},GetLayer[Obj1]<=GetLayer[Obj2]];


SetAttributes[Figure,{HoldFirst}];
  
Figure[Body_List,Opts___?OptionQ]:=Module[
{
(* option variables *)
FullOpts=RealizeOptions[Figure,Opts],
ExpansionFactor=10^-4,

(* work variables *)
SchemeList,
RawFrameLabel,
FormattedFrameLabel,
GraphicsPrimatives,
GraphicsOptions,
FullGraphics,
FrameStyleOpts,FrameTextStyleOpts,TickTextStyleOpts,
UsedPlotRange,
ErrorStatus,

(* pattern names *)
(* locally define pattern names used in scheme list processing, to avoid glitch if global value defined (though this is not really a concern in the Private context) *)
GraphicsObject,
Primatives

},

(* Flag entry into Scheme, for error handling mechanism *)
If[$InScheme,
Message[LevelScheme::notreentrant];
Return[]
];
Block[
{
$InScheme=True
},

(* Check options *)
If[CatchError[
If[
(PlotRange/.FullOpts)===Automatic,
Message[Scheme::prange]
];
CheckOption[PlotRange,Automatic|{{_?NumericQ,_?NumericQ},{_?NumericQ,_?NumericQ}},FullOpts];
CheckOption[ImageSize,Automatic|_?NumericQ|{_?NumericQ,_?NumericQ},FullOpts];
CheckOption[BlockOptions,{___Symbol},FullOpts];
CheckOption[SchemeFlags,{___String},FullOpts]
],
Return[]
];

(* Debugging *)
If[Information/.FullOpts,
Print[$Version];
Print[{$System,$SystemID,$OperatingSystem,$MachineType,$ProcessorType,$ByteOrdering,$MachineName}];
Print[$Path]
];

(* Clear any existing scheme data definitions *)
Clear["LevelScheme`Data`*","LevelScheme`Multipanel`*","LevelScheme`AutoLevel`"];

(* Set up coordinate systems *)
(* absolute size imitates Show, defaulting to 4*72, with GoldenRatio aspect ratio *)
$AbsSize=Switch[
(ImageSize/.FullOpts),
Automatic,4*72*{1,1/GoldenRatio},
_?NumericQ,(ImageSize/.FullOpts)*{1,1/GoldenRatio},
{_?NumericQ,_?NumericQ},(ImageSize/.FullOpts)
];
(* Plot range is expanded outwards by small fraction in each direction, beyond user-determined nominal range, so ending tick labels are guaranteed to fit in. *) 
UsedPlotRange=ExtendRegion[
N[GetAutoOption[PlotRange,{{0,1},{0,1}},FullOpts]],
(ExtendRange/.FullOpts)
];
$CanvasRange=ExtendRegion[UsedPlotRange,ExpansionFactor];
$P1C=First/@$CanvasRange;$P2C=Last/@$CanvasRange;
$TickScaleFactor=(Plus@@$AbsSize/2);
If[
CatchError[SetRegion[]],
Return[]
];

(* Initialize global state variables *)
$SchemeFlags=(SchemeFlags/.FullOpts);
$LastLevel=Null;
$Background=None;

(* Evaluate body *)
(* implements held calls to SetOptions, catches any Throw from option or parameter validation *)
Block[
{
$DisplayFunction=Identity
},
BlockOptions[
Union[OptionSymbols,OptionSymbols3D,(BlockOptions/.FullOpts)],
ErrorStatus=CatchError[SchemeList=Body]
]
];
(* handle possible error thrown by ErrorMessage, but only now after block constructs have restored all scoped values *)
If[ErrorStatus,
Return[]
];

(* Preprocess list of scheme objects *)
(* Flatten list *)
SchemeList=Flatten[SchemeList];
If[
Debug/.FullOpts,
Print["Object list after flattening: ",SchemeList//InputForm]
];
(* Strip any remaining unidentified objects *)
If[
Count[SchemeList,(_Graphics|_ContourGraphics|_DensityGraphics),{1}]!=0,
Message[Scheme::freegraphics]
];
SchemeList=Cases[SchemeList,_SchemeGraphics];
If[Debug/.FullOpts,
Print["Object list after cleanup: ",(SchemeList//InputForm)//TableForm]
];

(* Sort scheme by layer *)
SchemeList=Sort[SchemeList,SchemeGraphicsOrderedQ];

(* Extract all the graphics primatives *)
GraphicsPrimatives=Replace[
SchemeList,
{SchemeGraphics[Directives_List,Primatives_List,_]:>Join[Directives,Primatives]},
{1}
];
GraphicsPrimatives=Flatten[GraphicsPrimatives,1];
If[Debug/.FullOpts,
Print["Graphics size before directive pruning: ",ByteCount[GraphicsPrimatives]," bytes"]
];

(* Add PostScript comment *)
(*AppendTo[GraphicsPrimatives,PostScript["% This drawing was created using LevelScheme, Version "<>$RevisionString<>"."]];*)

(* Construct graphics display options *)
If[
CatchError[
FrameStyleOpts=MakeOutlineDirectives[FullOpts];
FrameTextStyleOpts=MakeTextStyle[FullOpts];
TickTextStyleOpts=MakeTextStyle[OptionsUnion[
FontFamily->GetAutoOption[TickFontFamily,FontFamily/.FullOpts,FullOpts],
FontSize->GetAutoOption[TickFontSize,FontSize/.FullOpts,FullOpts],
FontWeight->GetAutoOption[TickFontWeight,FontWeight/.FullOpts,FullOpts],
FontSlant->GetAutoOption[TickFontSlant,FontSlant/.FullOpts,FullOpts],
FontTracking->GetAutoOption[TickFontTracking,FontTracking/.FullOpts,FullOpts],
FontColor->GetAutoOption[TickFontColor,FontColor/.FullOpts,FullOpts],
FontOpacity->GetAutoOption[TickFontOpacity,FontOpacity/.FullOpts,FullOpts],
FullOpts
]]
],
Return[]
];
RawFrameLabel=Switch[
(FrameLabel/.FullOpts),
None,
None,
Automatic,
{LabB,LabL,LabT,LabR}/.FullOpts,
_List,
(FrameLabel/.FullOpts)
];
FormattedFrameLabel=Switch[
RawFrameLabel,
None,None,
_List,(If[#===None,None,DisplayForm[StyleForm[#,Sequence@@FrameTextStyleOpts]]])&/@RawFrameLabel
];
GraphicsOptions={
PlotRange ->$CanvasRange,
ImageSize->$AbsSize,AspectRatio->$AbsSize[[2]]/$AbsSize[[1]],
Frame-> (Frame/.FullOpts),
FrameStyle->Directive[FrameStyleOpts],
FrameLabel->FormattedFrameLabel,
FrameTicks->(FrameTicks/.FullOpts),
Axes->(Axes/.FullOpts),
Ticks->(Ticks/.FullOpts),
TextStyle->TickTextStyleOpts,
Background->(Background/.FullOpts),
DisplayFunction->(DisplayFunction/.FullOpts)
};
If[Debug/.FullOpts,
Print["Graphics options: ",GraphicsOptions]
];

(* Construct and render full graphics object *)
FullGraphics=Graphics[GraphicsPrimatives,GraphicsOptions];
Show[FullGraphics];

(* Delete scheme data definitions *)
Clear["LevelScheme`Data`*","LevelScheme`Multipanel`*","LevelScheme`AutoLevel`"];


(* Return result *)
FullGraphics

]
];


AutoLevelInit[Posn_,Space_,BigSpace_]  :=Module[{},
CheckInScheme[];
LevelScheme`AutoLevel`IDi = Null;
LevelScheme`AutoLevel`Posn = Posn;
LevelScheme`AutoLevel`Space = Space;
LevelScheme`AutoLevel`xbigSpace = BigSpace;
Null
];

AutoLevel[IDi_?LevelIdentifierQ]:=Module[{},
CheckInScheme[];
LevelScheme`AutoLevel`Posn+=If[TrueQ[LevelScheme`AutoLevel`IDi === Null], 0,LevelScheme`AutoLevel`xbigSpace-LevelScheme`AutoLevel`Space];
LevelScheme`AutoLevel`IDi=IDi
];

AutoTrans[IDf_?LevelIdentifierQ,Opts___?OptionQ]:=Module[
{Posn},
CheckInScheme[];
Posn=LevelScheme`AutoLevel`Posn;
LevelScheme`AutoLevel`Posn+=LevelScheme`AutoLevel`Space; 
Trans[LevelScheme`AutoLevel`IDi,Posn,IDf,Automatic,Opts]
];


ExtractLines[G:(_Graphics|_Graphics3D)]:=Cases[G,_Line,Infinity];
ExtractLines[CG:(_ContourGraphics)]:=ExtractLines[Graphics[CG]];


GrabPoints[G:(_Graphics|_Graphics3D|_ContourGraphics)]:=Module[
{Lines},

Lines=ExtractLines[G];
If[
Length[Lines]==0,
Message[GrabPoints::nolines]
];
If[
Length[Lines]>1,
Message[GrabPoints::manylines]
];
Lines[[1,1]]
];


LineStyle[Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[LineStyle,Opts]
},
MakeOutlineDirectives[FullOpts]
];


FillStyle[Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[FillStyle,Opts]
},
MakeFillDirectives[FullOpts]
];


IndentingNewline=FromCharacterCode[62371];
SchemeTemplateCell=Cell[BoxData[RowBox[{
RowBox[{
"Scheme","[",IndentingNewline,RowBox[{\({}\),",",IndentingNewline,\(PlotRange->\({\({0,1}\),\({0,1}\)}\)\),",",IndentingNewline,\(ImageSize->\(72*\({6,4}\)\)\)}],IndentingNewline,"]"
}],
";"
}]],"Input"];
SchemeTemplate[]:=CellPrint[SchemeTemplateCell];


LevelScheme[]:=Get["LevelScheme`"];


MultipanelSettings[]:=Module[
{SymbolNames},
SymbolNames=Names["LevelScheme`Multipanel`*"];
(Print[#," ",ToExpression[#]]&)/@SymbolNames
];


Expr:HoldPattern[Lev[___]]:=FallThroughError[Lev,Expr];
Expr:HoldPattern[ExtensionLine[___]]:=FallThroughError[ExtensionLine,Expr];
Expr:HoldPattern[Connector[___]]:=FallThroughError[Connector,Expr];
Expr:HoldPattern[Trans[___]]:=FallThroughError[Trans,Expr];
Expr:HoldPattern[ManualLabel[___]]:=FallThroughError[ManualLabel,Expr];
Expr:HoldPattern[ScaledLabel[___]]:=FallThroughError[ScaledLabel,Expr];
Expr:HoldPattern[BandLabel[___]]:=FallThroughError[BandLabel,Expr];
Expr:HoldPattern[LevelLabel[___]]:=FallThroughError[LevelLabel,Expr];
Expr:HoldPattern[SchemeBracket[___]]:=FallThroughError[SchemeBracket,Expr];Expr:HoldPattern[SchemeLine[___]]:=FallThroughError[SchemeLine,Expr];
Expr:HoldPattern[SchemePoints[___]]:=FallThroughError[SchemePoints,Expr];
Expr:HoldPattern[SchemePolygon[___]]:=FallThroughError[SchemePolygon,Expr];
Expr:HoldPattern[SchemeCircle[___]]:=FallThroughError[SchemeCircle,Expr];
Expr:HoldPattern[SchemeEllipse[___]]:=FallThroughError[SchemeEllipse,Expr];
Expr:HoldPattern[SchemeBox[___]]:=FallThroughError[SchemeBox,Expr];
Expr:HoldPattern[SchemeSquare[___]]:=FallThroughError[SchemeSquare,Expr];
Expr:HoldPattern[SchemeArrow[___]]:=FallThroughError[SchemeArrow,Expr];
Expr:HoldPattern[RawGraphics[___]]:=FallThroughError[RawGraphics,Expr];
Expr:HoldPattern[ViewPort3D[___]]:=FallThroughError[ViewPort3D,Expr];
Expr:HoldPattern[ScaledViewPort3D[___]]:=FallThroughError[ViewPort3D,Expr];
Expr:HoldPattern[FigurePanel[___]]:=FallThroughError[FigurePanel,Expr];
Expr:HoldPattern[ScaledFigurePanel[___]]:=FallThroughError[ScaledFigurePanel,Expr];
Expr:HoldPattern[Multipanel[___]]:=FallThroughError[Multipanel,Expr];
Expr:HoldPattern[SchemeAxis[___]]:=FallThroughError[SchemeAxis,Expr];

Expr:HoldPattern[PanelLetter[___]]:=FallThroughError[PanelLetter,Expr];
Expr:HoldPattern[LineStyle[___]]:=FallThroughError[LineStyle,Expr];
Expr:HoldPattern[FillStyle[___]]:=FallThroughError[FillStyle,Expr];

Expr:HoldPattern[DataPlot[___]]:=FallThroughError[DataPlot,Expr];
Expr:HoldPattern[DataLegend[___]]:=FallThroughError[DataLegend,Expr];
Expr:HoldPattern[DataTag[___]]:=FallThroughError[DataTag,Expr];
Expr:HoldPattern[SaveDataStyle[___]]:=FallThroughError[SaveDataStyle,Expr];
Expr:HoldPattern[SetDataStyle[___]]:=FallThroughError[SetDataStyle,Expr];
Expr:HoldPattern[DataLabel[___]]:=FallThroughError[DataLabel,Expr];

Expr:HoldPattern[SetRegion[___]]:=FallThroughError[SetRegion,Expr];
Expr:HoldPattern[SetOrigin[___]]:=FallThroughError[SetOrigin,Expr];
Expr:HoldPattern[SetScale[___]]:=FallThroughError[SetScale,Expr];

Expr:HoldPattern[ConvertCoordinate[___]]:=FallThroughError[ConvertCoordinate,Expr];
Expr:HoldPattern[ConvertRange[___]]:=FallThroughError[ConvertRange,Expr];
Expr:HoldPattern[ConvertRegion[___]]:=FallThroughError[ConvertRegion,Expr];

Expr:HoldPattern[ManualLabel3D[___]]:=FallThroughError[ManualLabel3D,Expr];Expr:HoldPattern[SchemeLine3D[___]]:=FallThroughError[SchemeLine3D,Expr];
Expr:HoldPattern[SchemeArrow3D[___]]:=FallThroughError[SchemeArrow3D,Expr];
Expr:HoldPattern[RawGraphics3D[___]]:=FallThroughError[RawGraphics3D,Expr];


Expr:HoldPattern[Figure[___]]:=Message[Scheme::args,Scheme];


Expr:HoldPattern[AttachIndex[___]]:=Message[AttachIndex::args,HoldForm[Expr]];


SetSchemeOrigin[Args___]:=Module[
{},
Message[SetSchemeOrigin::deprecated];
SetOrigin[Args]
];
SetSchemeScale[Args___]:=Module[
{},
Message[SetSchemeScale::deprecated];
SetScale[Args]
];
SetSchemeRegion[Args___]:=Module[
{},
Message[SetSchemeRegion::deprecated];
SetRegion[Args]
];
TransArrow[Args___] :=Module[
{},
Message[TransArrow::deprecated];
Trans[Args]
];
AnnotateL[ID_,Args___] :=Module[
{},
Message[AnnotateL::deprecated];
LevelLabel[ID,Left,Args]
];
AnnotateR[ID_,Args___] :=Module[
{},
Message[AnnotateR::deprecated];
LevelLabel[ID,Right,Args]
];
ExtensionLineL[ID_,Args___] :=Module[
{},
Message[ExtensionLineL::deprecated];
ExtensionLine[ID,Left,Args]
];
ExtensionLineR[ID_,Args___] :=Module[
{},
Message[ExtensionLineR::deprecated];
ExtensionLine[ID,Right,Args]
];
SchemeAxisB[Args___] :=Module[
{},
Message[SchemeAxisB::deprecated];
SchemeAxis[Bottom,Args]
];
SchemeAxisL[Args___] :=Module[
{},
Message[SchemeAxisL::deprecated];
SchemeAxis[Left,Args]
];
SchemeAxisT[Args___] :=Module[
{},
Message[SchemeAxisT::deprecated];
SchemeAxis[Top,Args]
];
SchemeAxisR[Args___] :=Module[
{},
Message[SchemeAxisR::deprecated];
SchemeAxis[Right,Args]
];
RegionLabel[Args___] :=Module[
{},
Message[RegionLabel::deprecated];
ScaledLabel[Args]
];
AutoInit[Args___]:=Module[
{},
Message[AutoInit::deprecated];
AutoLevelInit[Args]
];
AutoPanel[Args___]:=Module[
{},
Message[AutoPanel::replaced]
];
AutoPanelInit[Args___]:=Module[
{},
Message[AutoPanelInit::replaced]
];
ResetCoordinates[]:=Module[
{},
Message[ResetCoordinates::deprecated];
SetRegion[]
];


Scheme=Figure;


SchemePoints[Points_List,Opts___?OptionQ]:=Module[
{
FullOpts=RealizeOptions[SchemePoints,Opts],
BasicShape,i,Point,PointVertices,CentralPoints,ExpandedErrorPoints,ErrorBars
},

Message[SchemePoints::deprecated];
CheckInScheme[];
CheckOption[SymbolSize,(_?NumericQ)?Positive,FullOpts];
CheckOption[PlotPoints,_Integer?Positive,FullOpts];

(* Construct points *)
BasicShape=DPCOfPA/@((SymbolSize/.FullOpts)*N[DataSymbolShape[(SymbolShape/.FullOpts),(PlotPoints/.FullOpts)]]);
If[!MatchQ[BasicShape,{{_?NumericQ,_?NumericQ}..}],ErrorMessage[DataPlot::badsymbol,(SymbolShape/.FullOpts)]];
CentralPoints=(Points/.{ErrorValue[x_,_]:>x});
PointVertices=TableForEach[
(PCOfPU[Point]+#)&/@BasicShape,
{Point,CentralPoints}
];

(* Construct error bars *)
ExpandedErrorPoints=(Points/.{ErrorValue[x_,dx_]:>ErrorValue[x,{-dx,dx}]});
ErrorBars=Join[
Cases[
ExpandedErrorPoints,
{(x_)|ErrorValue[x_,_],ErrorValue[y_,{dym_,dyp_}]}:>ErrorBarPrimatives[Vertical,{x,y},{dym,dyp},(SymbolSize/.FullOpts)]
],
Cases[
ExpandedErrorPoints,
{ErrorValue[x_,{dxm_,dxp_}],(y_)|ErrorValue[y_,_]}:>ErrorBarPrimatives[Horizontal,{x,y},{dxm,dxp},(SymbolSize/.FullOpts)]
]
];

(* Draw artwork *)

{

(* Error bars -- behind fill *)
MakeOutline[
{
ErrorBars
},
FullOpts],

(* Fill *)

MakeFill[
{
Polygon/@PointVertices
},
FullOpts],

(* Outline *)

MakeOutline[
{
(Line[Append[#,First[#]]]&)/@PointVertices
},
FullOpts]

}

];


End[];


Protect[Evaluate[$Context<>"*"]];
Unprotect[Evaluate[$Context<>"DataLineShape"]];
Unprotect[Evaluate[$Context<>"DataSymbolShape"]];
EndPackage[];
