(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* :Title: InheritOptions *)
(* :Context: InheritOptions` *)
(* :Author: Mark A. Caprio, Center for Theoretical Physics, Yale University *)
(* :Summary: Option value inheritance system and miscellaneous option processing utilities. *)
(* :Copyright: Copyright 2007, Mark A. Caprio *)
(* :Package Version: 1.2 *)
(* :Mathematica Version: 6.0 *)
(* :History:
 V1.0, March 8, 2005.  CPCPL distribution.
 V1.1, July 8, 2005.  Added KnownOptions.  MathSource distribution.
 V1.2, August 3, 2007.  Mathematica 6 compatibility update to avoid overwriting Inherited:usage.
*)


BeginPackage["InheritOptions`"];


Unprotect[Evaluate[$Context<>"*"]];


KnownOptions::usage="KnownOptions[symbol] returns a sorted list of known options for symbol.";
KnownOption::usage="KnownOption[symbol,option] returns true if option is a known option for symbol.";
FlatOptionListQ::usage="FlatOptionListQ[x] returns True if x is a flat list of option specifications, i.e., rules matching (_Symbol\[Rule]_)|(_Symbol\[RuleDelayed]_).  It is thus more specific than the standard OptionQ.";
GetAutoOption::usage="GetAutoOption[option,default,optionlist] retrieves the value for option specified in optionlist, substituting defaultvalue if option value is Automatic.";
OptionsSort::usage="OptionsSort[options] flattens an option specification and sorts by option name.  Order is preserved for rules for the same option.";
OptionsUnion::usage="OptionsUnion[options] flattens an option specification and sorts by option name.   Only the first rule for each option is preserved.";
DuplicatedOptions::usage="DuplicatedOptions[options] returns a list of all options which are specified more than once in options.";
DefineOptions::usage="DefineOptions[symbol,{parent,{inheritedoption,...}},...,{newoption->value,...}] set up option iheritance for symol.  The value All may be given instead of an explicit list of inherited options.  An inherited option may be given as a rule, in which case the default value is not Inherited.  It defines Options and OptionParents values for symbol";
RealizeOptions::usage="RealizeOptions[symbol] produces a list (flattened, sorted, and with duplicate option specifications eliminated) of option value rules for symbol, with any options given to RealizeOptions taking precedence over Options[symbol].  Option values are inherited if appropriate.  Checks for illegal inheritance and unknown options are carried out if these were enabled when option inheritance was originally set up for symbol.";
OptionRealizationRules::usage="OptionRealizationRules[symbol] is a list or dispatch table of rules for realizing the inherited option values for symbol and checking option validity.";
Inherited::reusage="Option value indicating the actual value used should be inherited."; (*System`*)
TrapUninheritableOptions::usage="Option for DefineOptions";
TrapUnknownOptions::usage="Option for DefineOptions";
$UninheritableOption::usage="Global variable containing error handler function for attempt to inherit option which does not come from any parent.  Arguments are object name, option name, and full rule.";
$UnknownOption::usage="Global variable containing error handler function for presence of option which is not defined for object.  Arguments are object name, option name, and full rule.";


DefineOptions::badparent="Symbol `1` cannot be used as a parent for option inheritance, since its option list is not valid or was not defined using DefineOptions."; 
DefineOptions::undef="Option `2` is not defined for parent symbol `1`."; 
DefineOptions::duplicate="Symbol has been given multiple definitions of option `1`."; 
General::uninheritopt="Option `2` is not an inheritable option for `1`.";
(* alternative to standard ::optx *)
General::unknownopt="Unknown option `2` specified for `1`."; 


Begin["`Private`"];


(* Private copy of DoForEach, from package ForEach, version 1.0. *)


SetAttributes[DoForEach,HoldAll];
DoForEach[Expr_,{Var_Symbol,ValueSet_}]:=Module[
{i},

If[
Head[ValueSet]=!=List,
Message[DoForEach::notlist,ValueSet]
];
Do[
Block[
{Var=ValueSet[[i]]},
Expr
],
{i,1,Length[ValueSet]}
]

];
DoForEach[Expr_,{Var_Symbol,CountVar_Symbol,ValueSet_}]:=Module[
{i},

If[
Head[ValueSet]=!=List,
Message[DoForEach::notlist,ValueSet]
];

Block[
{CountVar},
Do[
CountVar=i;
Block[
{Var=ValueSet[[i]]},
Expr
],
{i,1,Length[ValueSet]}
]
]

];
DoForEach[Expr_,FirstIterator_List,RestIteratorSeq__List]:=DoForEach[DoForEach[Expr,RestIteratorSeq],FirstIterator];


(* Private copy of DoForEach, from package ForEach, version 1.0. *)


Options[TableForEach]={Flatten->False};
SetAttributes[TableForEach,HoldAll];
TableForEach[Expr_,{Var_Symbol,ValueSet_},Opts___?OptionQ]:=Module[
{i},

If[
Head[ValueSet]=!=List,
Message[TableForEach::notlist,ValueSet]
];
Table[
Block[
{Var=ValueSet[[i]]},
Expr
],
{i,1,Length[ValueSet]}
]

];
TableForEach[Expr_,{Var_Symbol,CountVar_Symbol,ValueSet_},Opts___?OptionQ]:=Module[
{i},

If[
Head[ValueSet]=!=List,
Message[TableForEach::notlist,ValueSet]
];

Block[
{CountVar},
Table[
CountVar=i;
Block[
{Var=ValueSet[[i]]},
Expr
],
{i,1,Length[ValueSet]}
]
]
];
TableForEach[Expr_,FirstIterator:{_Symbol,_},RestIteratorSeq:({_Symbol,_}..),Opts___?OptionQ]:=Module[
{FullOpts=Flatten[{Opts,Options[TableForEach]}]},
If[Flatten/.FullOpts,
Flatten[TableForEach[TableForEach[Expr,RestIteratorSeq,Opts],FirstIterator],1],
TableForEach[TableForEach[Expr,RestIteratorSeq],FirstIterator]
]
];


KnownOptions[Object_Symbol]:=Union[First/@Options[Object]];KnownOption[Object_Symbol,Option_Symbol]:=MemberQ[KnownOptions[Object],Option];


FlatOptionListQ[x_]:=MatchQ[x,{((_Symbol->_)|(_Symbol:>_))...}];


OptionsSort[Opts___?OptionQ]:=Sort[Flatten[{Opts}],OrderedQ[First/@{#1,#2}]&];


OptionsUnion[Opts___?OptionQ]:=First/@Split[OptionsSort[Opts],SameQ[First[#1],First[#2]]&];


DuplicatedOptions[Opts___?OptionQ]:=First/@First/@Select[Split[OptionsSort[Opts],SameQ[First[#1],First[#2]]&],(Length[#]>1)&];


GetAutoOption[Option_Symbol,DefaultValue_,FullOpts_?FlatOptionListQ]:=Module[
{Value},
Value=(Option/.FullOpts);
If [Value===Automatic,DefaultValue,Value]
];


Options[DefineOptions]={TrapUninheritableOptions->True,TrapUnknownOptions->True};
DefineOptions[Object_Symbol,RawInheritanceSeq:({_Symbol,_List|All}...),RawNewOptions:{___?OptionQ},Opts___?OptionQ]:=Module[
{
FullOpts=Flatten[{Opts,Options[DefineOptions]}],
RawInheritanceList={RawInheritanceSeq},
NewOptions=Flatten[RawNewOptions],
Pair,Parent,OptionList,Option,
InheritanceList,ObjectOptions,BasicInheritanceRules,ErrorTrapRules,FullRule
},
Catch[
(* audit and expand inheritance list *)
InheritanceList=TableForEach[

(* break down raw pair *)
{Parent,OptionList}=Pair;

(* audit parent option list *)
If[
!FlatOptionListQ[Options[Parent]],
Message[DefineOptions::badparent,Parent];Throw[Null]
];
If[
!MatchQ[OptionRealizationRules[Parent],_List|_Dispatch],
Message[DefineOptions::badparent,Parent];Throw[Null]
];

(* expand All value to list of options *)
OptionList=Replace[OptionList,All->First/@Options[Parent]];

(* expand plain option names to rules with value Inherited *)
OptionList=Replace[OptionList,Option_Symbol:>(Option->Inherited),{1}];

(* check that all options are inheritable from parent *)
DoForEach[
If[
!KnownOption[Parent,Option],
Message[DefineOptions::undef,Parent,Option];Throw[Null]
],
{Option,First/@OptionList}
];

(* return completed pair *)
{Parent,OptionList},
{Pair,RawInheritanceList}
];

(* construct full option list *)
(* combine inherited and new options, without duplicate elimination *)
ObjectOptions=OptionsSort[Last/@InheritanceList,NewOptions];
(* check for duplicated options *)
DoForEach[
Message[DefineOptions::duplicate,Option];Throw[Null],
{Option,DuplicatedOptions[ObjectOptions]}
];
(* save resulting options list *)
Options[Object]=ObjectOptions;

(* construct inheritance rules *)
(* Rule and RuleDelay in each case treated separately to facilitate construction of Dispatch table *)
Block[
{InheritOption,$UninheritableOption,$UnknownOption},
BasicInheritanceRules=TableForEach[
(* break down pair *)
{Parent,OptionList}=Pair;
OptionList=First/@OptionList;
(* return list of rule transformation *)
TableForEach[
{
(Option->Inherited):>Evaluate[InheritOption[Parent,Option]],
(Option:>Inherited):>Evaluate[InheritOption[Parent,Option]]
},
{Option,OptionList}
],
{Pair,InheritanceList}
];
ErrorTrapRules={
If[
TrapUninheritableOptions/.FullOpts,
TableForEach[
{
FullRule:(Option->Inherited):>Evaluate[$UninheritableOption[Object,Option,FullRule]],
FullRule:(Option:>Inherited):>Evaluate[$UninheritableOption[Object,Option,FullRule]]
},
{Option,First/@NewOptions}
],
{}
],
If[
TrapUnknownOptions/.FullOpts,
FullRule:((Option_Symbol->Value_)|(Option_Symbol:>Value_))/;!KnownOption[Object,Option]:>Evaluate[$UnknownOption[Object,Option,FullRule]],
{}
]
};
OptionRealizationRules[Object]^=Dispatch[Flatten[{BasicInheritanceRules,ErrorTrapRules}]]
]
];
Null
];


InheritOption[Parent_Symbol,Option_Symbol]:=Module[
{ParentRule,ParentValue},

(* extract parent's rule for option *)
ParentRule=First[Cases[Options[Parent],(Option->_)|(Option:>_),{1},1]];

(* check whether parent again inherits *)
(* Hold is to avoid direct evaluation in case of RuleDelayed with side effects *)
ParentValue=Extract[ParentRule,{2},Hold];
If[
ParentValue===Hold[Inherited],
Replace[Option->Inherited,OptionRealizationRules[Parent]],
ParentRule
]
];


$UninheritableOption=Function[{Object,Option,FullRule},Message[Object::uninheritopt,Object,Option];FullRule];
$UnknownOption=Function[{Object,Option,FullRule},Message[Object::unknownopt,Object,Option];FullRule];


RealizeOptions[Object_Symbol,Opts___?OptionQ]:=Replace[OptionsUnion[Opts,Options[Object]],OptionRealizationRules[Object],{1}];


End[];


Protect[Evaluate[$Context<>"*"]];
Unprotect[Evaluate[$Context<>"$*"]];
EndPackage[];



